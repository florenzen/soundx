/**
 * Processing of SDF2 sections
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/sxbld/processing/GrammarElems

imports org/sugarj/languages/SXBld

imports org/sugarj/soundx/AbstractSyntax

imports org/sugarj/sxbld/Environment
        org/sugarj/sxbld/Analysis

imports org/sugarj/sxbld/processing/SortPrefixing
        org/sugarj/sxbld/processing/SDF2Terms
        //org/sugarj/sxbld/processing/Symbols

/**
 * Register analyses and desugarings
 */
strategies
	sxbld-start-analysis = sxbld-analyze-grammar-elems

strategies
	/**
	 * Analyzes list of SDF2 sections
	 *
	 * @type SXBldGrammarElems -> SXBldGrammarElems
	 */
	sxbld-analyze-grammar-elems =
		?SXBldGrammarElems(grammars);
		debug(!"FINISHED ");
		where(
			<map(sxbld-analyze-grammar-elem); concat> grammars;
		    // Not using mapconcat here because it traverses the list from the end to front
		    // which lowers quality of error messages
			sxbld-add-grammar-elems)

    /**
     * Analyzes a single SDF2 section
     *
     * @type Grammar -> List(Grammar)
     */
    sxbld-analyze-grammar-elem =
        ((sxbld-analyze-sorts +
          sxbld-analyze-cf-syntax +
          sxbld-analyze-lex-syntax +
          sxbld-analyze-variables +
          sxbld-analyze-lex-priorities +
          sxbld-analyze-cf-priorities +
          sxbld-analyze-lex-restrictions +
          sxbld-analyze-cf-restrictions) <+
         sxbld-analyze-unsupported(|"Unsupported SDF 2 section"));
        (?[_|_] <+ ![<id>])

	/**
	 * Passes on lexical priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-lex-priorities =
		?lexical-priorities(_); sxbld-prefix-all-sorts-base-lang
	
   /**
	 * Passes on context-free priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-cf-priorities =
		?context-free-priorities(_); sxbld-prefix-all-sorts-base-lang

    /**
	 * Passes on lexical restrictions untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-lex-restrictions =
		?lexical-restrictions(_); sxbld-prefix-all-sorts-base-lang

	/**
	 * Passes on context-free priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-cf-restrictions =
		?context-free-restrictions(_); sxbld-prefix-all-sorts-base-lang

	/**
	 * Analyzes a variables section
	 *
	 * Transforms it into a context-free section with
	 * constructor attributes and a lexical section.
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-variables =
	    variables(sxbld-prefix-all-sorts-base-lang)
		// ?variables(prods);
		// <map(sxbld-analyze-variable-prod)> prods => cf-lex-prods;
		// <unzip> cf-lex-prods => (cf-prods, lex-prods);
		// ![context-free-syntax(cf-prods), lexical-syntax(lex-prods)]

	/**
	 * Analyzes a variable production
	 *
	 * @type Sdf2Production -> (Sdf2Production, Sdf2Production)
	 */
	// sxbld-analyze-variable-prod =
	// 	?prod(lhs-symbols, rhs-symbol, attributes);
	// 	<sxbld-analyze-variable-prod-rhs> rhs-symbol => analyzed-rhs-symbol;
	// 	<sxbld-analyze-variable-prod-attributes-lex(|analyzed-rhs-symbol)> attributes =>
	// 	  (analyzed-attributes, lex-rhs);
	// 	<sxbld-prefix-all-sorts-base-lang> lhs-symbols => lhs-symbols-prefixed;
	// 	<sxbld-prefix-all-sorts-base-lang> analyzed-rhs-symbol => prefixed-rhs-symbol;
	// 	!(prod([lex-rhs], prefixed-rhs-symbol, analyzed-attributes),
	// 	  prod(lhs-symbols-prefixed, lex-rhs, no-attrs()))

    /**
     * Checks that right-hand side is of supported format
     *
     * This aligns with the supported context-free and
     * lexical reight-hand sides.
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    // sxbld-analyze-variable-prod-rhs =
	   //  ?sort(_) <+
    // 	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Checks that a variable production has no attributes
     *
     * @type Sdf2Attributes -> (Sdf2Attributes, Sdf2Symbol)
     */
// 	sxbld-analyze-variable-prod-attributes-lex(|rhs-symbol) =
// 		// No attributes
// 		?no-attrs();
// 		<sxbld-analyze-variable-cons-name> rhs-symbol => cons-name;
// 		<sxbld-analyze-variable-lex-rhs-name> rhs-symbol => lex-rhs-name;
// 		!(attrs([prefer(), <sxbld-sdf2-cons-attribute> cons-name]),
// 		  sort(lex-rhs-name))
// 	sxbld-analyze-variable-prod-attributes-lex(|rhs-symbol) =
// 		// Some attributes
// 		?attrs(_);
// 		sxbld-analyze-unsupported(|"Attributes not supported in variables section")
// 
// 	sxbld-analyze-variable-lex-rhs-name:
//     	sort(name) -> rhs-name
//     	where
//     		<conc-strings> ("SXMetaVar", name) => rhs-name
    
    /**
     * Generate a constructor name for the metavariable
     *
     * The constructor name is <base language name>MetaVar<sort-name>.
     *
     * @type Sdf2Symbol -> String
     */
    // sxbld-analyze-variable-cons-name:
    // 	sort(name) -> cons-name
    // 	where
    // 		<conc-strings> ("SXMetaVar", name) => cons-name
    // 		//<sxbld-env-get-base-language-name> () => base-language-name;
    // 		//<conc-strings> (base-language-name, "MetaVar", name) => cons-name
    // 		// <sxbld-sdf2-cons-attribute> cons-name => cons-attribute

    /**
     * Analyzes a sorts section
     *
     * @type Grammar -> Grammar
     */
    sxbld-analyze-sorts =
        'sorts(sxbld-prefix-all-sorts-base-lang)
    	// <map(sxbld-analyze-symbol); sxbld-prefix-all-sorts-base-lang> symbols => analyzed-symbols;
   	 //    !'sorts(analyzed-symbols)

    /**
     * Checks for unsupported sort declarations
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    // sxbld-analyze-symbol =
    // 	?sort(_) <+
    // 	sxbld-analyze-unsupported(|"Unsupported sort declaration")

    /**
     * Succeeds if two sorts are equal, fails otherwise
     *
     * @type (SXAbsSort, SXAbsSort) -> (SXAbsSort, SXAbsSort)
     */
    // sxbld-sorts-equal =
   	// 	?(SXAbsSortLexical(), SXAbsSortLexical()) +
   	// 	?(SXAbsSortContextFree(), SXAbsSortContextFree())

    /**
     * Adds a sort to the environment
     *
     * If a sort of the same name is already defined the two
     * sorts must be equal, otherwise the analysis fails.
     *
     * @type (String, SXAbsSort) -> SXEnv
     */
    // sxbld-add-sort =
    // 	?(name, sort);
    // 	<sxbld-env-get-sort> name;
    // 	if ?None() then
    // 		<sxbld-env-add-sort> (name, sort)
    // 	else
    // 		?Some(other-sort);
    // 		if <sxbld-sorts-equal> (sort, other-sort) then
    // 			<sxbld-get-env-hashtable> () // Return the environment in any case
    // 		else
    // 			<sxbld-analyze-fail(|"Invalid redeclaration of sort")> name
    // 		end
    // 	end

    /**
     * Analyzes a context-free syntax section
     *
     * @type Grammar -> Gramar
     */
    sxbld-analyze-cf-syntax =
    	?context-free-syntax(prods);
    	<map(sxbld-analyze-cf-production); concat> prods => analyzed-prods;
        !context-free-syntax(analyzed-prods)

    /**
     * Analyzes a context-free production
     *
     * Adds an arity for that production to the environment.
     *
     * @type Sdf2Production -> Sdf2Production
     */
    sxbld-analyze-cf-production =
    	?prod(symbols, symbol, attributes);
    	//<sxbld-analyze-cf-rhs> symbol => (analyzed-symbol, sort-name);
    	<sxbld-analyze-cf-attributes> attributes => analyzed-attributes;
    	// <sxbld-analyze-symbols-to-sorts> symbols => sort-names;
    	//try(!option-cons-name;
    	//    ?Some(cons-name);
    	//    // Cannot fail since sxbld-analyze-cf-attributes checks for duplicate
    	//    // names of user defined cons attributes.
    	//    <sxbld-analyze-add-arity> (cons-name, SXAbsArity(sort-names, sort-name)));
    	<sxbld-prefix-all-sorts-base-lang> symbol => prefixed-symbol;
    	<sxbld-prefix-all-sorts-base-lang> symbols => prefixed-symbols;
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbols => prefixed-ground-symbols;
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => prefixed-ground-symbol;
    	![prod(prefixed-symbols, prefixed-symbol, analyzed-attributes),
    	  prod(prefixed-ground-symbols, prefixed-ground-symbol, analyzed-attributes)]

    /**
     * Checks attributes of context-free production
     *
     * Generates a constructor name if necessary, includes it in
     * the analyzed attributes and also returns it.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     *
     * @type Sdf2Attributes -> Sdf2Attributes
     */
    sxbld-analyze-cf-attributes =
    	((?no-attrs(); ![]) +
    	 (?attrs(attrib-list); !attrib-list));
    	sxbld-analyze-cf-attribute-list-cons => attrib-list-with-cons;
    	!attrs(attrib-list-with-cons)

    /**
     * Adds or prefixes a cons attribute
     *
     * It returns the new attribute list and the name of the constructor.
     * If a constructor name is given in an attribut the exact string from
     * the input is returned. Therefore, the constructor name is double-qouted.
     *
     * A constructor is only returned if the attribute list does not contain a
     * bracket attribute.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     * @type List(Sdf2Attribute) -> List(Sdf2Attribute)
     */
    sxbld-analyze-cf-attribute-list-cons =
    	where(<elem> (bracket(), <id>)) <
    	// bracket attribute, return attributes untouched
    	id +
    	// No bracket attribute
    	(partition(sxbld-sdf2-is-attribute(|"cons")) => (cons-attribs, other-attribs);
    	 ((// No cons attribute, generate one
    	   !cons-attribs; ?[];
     	   sxbld-env-fresh-cons-name => cons-name;
		   sxbld-env-add-cons-name;
    	   ![<sxbld-sdf2-cons-attribute> cons-name | other-attribs]) <+
    	  (// One cons attribute, prefix it
    	   !cons-attribs; ?[cons-attrib];
    	   <sxbld-sdf2-cons-attribute-name-quoted> cons-attrib => cons-name-quoted;
    	   <un-double-quote> cons-name-quoted => cons-name;
    	   <sxbld-env-prefix-name> cons-name => prefixed-cons-name;
		   if sxbld-env-cons-name-defined then
		   	   <sxbld-analyze-fail(|"Duplicate constructor name")> cons-name-quoted
		   else
		   	   <sxbld-env-add-cons-name> prefixed-cons-name;
    	       ![<sxbld-sdf2-cons-attribute> prefixed-cons-name | other-attribs]
    	   end) <+
    	  (// More than one cons attribute, error
    	   !cons-attribs; ?[_,_|_];
    	   <map(sxbld-analyze-fail(|"Several cons attributes are not allowed"))> cons-attribs)))
        
    /**
     * Analyzes the right-hand side of a context-free production
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    // sxbld-analyze-cf-rhs =
    // 	sxbld-analyze-cf-rhs-sort <+
    // 	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Adds the right-hand side sort as SXAbsSortContextFree() to environment
     *
     * @type Symbol -> SXEnv
     */
    // sxbld-analyze-cf-rhs-sort =
    // 	?symbol@sort(name);
    // 	<sxbld-add-sort> (name, SXAbsSortContextFree());
    // 	!(symbol, name)

    /**
     * Analyzes a lexical syntax section
     *
     * @type Grammar -> Gramar
     */
    sxbld-analyze-lex-syntax =
    	?lexical-syntax(prods);
    	<map(sxbld-analyze-lex-production); unzip; (concat, concat)> prods => (lex-prods, cf-prods);
        ![lexical-syntax(lex-prods), context-free-syntax(cf-prods)]

    /**
     * Analyzes a lexical production
     *
     * @type Sdf2Production -> (List(Sdf2Production), List(Sdf2Production))
     */
    sxbld-analyze-lex-production =
    	?prod(symbols, symbol, attributes);
    	//<sxbld-analyze-lex-rhs> symbol => (analyzed-symbol, sort-name);
    	<sxbld-prefix-all-sorts-base-lang> [symbol|symbols] => [prefixed-symbol|prefixed-symbols];
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbols => ground-symbols;
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => ground-symbol;
    	// Generate syntax production for inequality judgement if sx-requires-inequality is given
    	((!attributes; ?attrs(attribute-list); !attribute-list) <+ ![]) => attribute-list;
    	if <elem> (term(default(fun(unquoted("sx-requires-inequality")))), attribute-list) then
    		![prod([prefixed-symbol, lit("=/="), prefixed-symbol], sort("SXJudgement"),
    	           attrs([<sxbld-sdf2-cons-attribute> "SXNeq"]))]
    	else
    		![]
    	end => cf-prods;
    	!([prod(prefixed-symbols, prefixed-symbol, attributes),
    	   prod(ground-symbols, ground-symbol, attributes)],
    	  cf-prods)
    	  

    /**
     * Analyzes the right-hand side of a lexical production
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    // sxbld-analyze-lex-rhs =
    // 	sxbld-analyze-lex-rhs-sort <+
    // 	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Adds the right-hand side sort as SXAbsSortLexical() to environment
     *
     * @type Symbol -> SXEnv
     */
    // sxbld-analyze-lex-rhs-sort =
    // 	?symbol@sort(name);
    // 	<sxbld-add-sort> (name, SXAbsSortLexical());
    // 	!(symbol, name)
   
   sxbld-add-grammar-elems =
   	   map(\grm -> grammar-elem(grm)\);
   	   sxbld-env-add-grammar-elems

    /**
     * Adds the grammars to the environment
     *
     * @type SXBldGrammarElems -> SXEnv
     */   
    sxbld-desugar-grammar-elems =
    	?SXBldGrammarElems(grammars);
    	//<sxbld-prefix-all-sorts-base-lang> grammars => renamed-grammars;
    	<map(\grm -> grammar-elem(grm)\)> grammars => grammar-elems;
    	<sxbld-env-add-grammar-elems> grammar-elems
