/**
 * Processing of SDF2 sections
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/sxbld/processing/GrammarElems

imports org/sugarj/languages/SXBld

imports org/sugarj/soundx/AbstractSyntax

imports org/sugarj/sxbld/Environment
        org/sugarj/sxbld/Analysis

imports org/sugarj/sxbld/processing/SortRenaming
        org/sugarj/sxbld/processing/SDF2Terms

strategies
	/**
	 * Register analyses and desugarings
	 */
	sxbld-desugar-to-env = sxbld-desugar-grammar-elems
	sxbld-start-analysis = sxbld-analyze-grammar-elems

	/**
	 * Analyzes list of SDF2 sections
	 *
	 * @type SXBldGrammarElems -> SXBldGrammarElems
	 */
	sxbld-analyze-grammar-elems =
		?SXBldGrammarElems(grammars);
		<map(sxbld-analyze-grammar-elem)> grammars => analyzed-grammars;
		!SXBldGrammarElems(analyzed-grammars)

    /**
     * Analyzes a single SDF2 section
     *
     * @type Grammar -> Grammar
     */
    sxbld-analyze-grammar-elem =
        (sxbld-analyze-sorts +
         sxbld-analyze-cf-syntax +
         sxbld-analyze-lex-syntax +
         sxbld-analyze-variables +
         sxbld-analyze-lex-priorities +
         sxbld-analyze-cf-priorities +
         sxbld-analyze-lex-restrictions +
         sxbld-analyze-cf-restrictions) <+
        sxbld-analyze-unsupported(|"Unsupported SDF 2 section")

	/**
	 * Passes on lexical priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-lex-priorities =
		?lexical-priorities(_)
	
   /**
	 * Passes on context-free priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-cf-priorities =
		?context-free-priorities(_)

    /**
	 * Passes on lexical restrictions untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-lex-restrictions =
		?lexical-restrictions(_)

	/**
	 * Passes on context-free priorities untouched
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-cf-restrictions =
		?context-free-restrictions(_)

	/**
	 * Analyzes a variables section
	 *
	 * Transforms it into a context-free section with
	 * constructor attributes.
	 *
	 * @type Grammar -> Grammar
	 */
	sxbld-analyze-variables =
		?variables(prods);
		<map(sxbld-analyze-variable-prod)> prods => analyzed-prods;
		!context-free-syntax(analyzed-prods)

	/**
	 * Analyzes a variable production
	 *
	 * @type Sdf2Production -> Sdf2Production
	 */
	sxbld-analyze-variable-prod =
		?prod(lhs-symbols, rhs-symbol, attributes);
		<sxbld-analyze-variable-prod-rhs> rhs-symbol => analyzed-rhs-symbol;
		<sxbld-analyze-variable-prod-attributes(|analyzed-rhs-symbol)> attributes => analyzed-attributes;
		!prod(lhs-symbols, analyzed-rhs-symbol, analyzed-attributes)

    /**
     * Checks that right-hand side is of supported format
     *
     * This aligns with the supported context-free and
     * lexical reight-hand sides.
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    sxbld-analyze-variable-prod-rhs =
	    ?sort(_) <+
    	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Checks that a variable production has no attributes
     *
     * @type Sdf2Attributes -> Sdf2Attributes
     */
	sxbld-analyze-variable-prod-attributes(|rhs-symbol) =
		// No attributes
		?no-attrs();
		!attrs([prefer(), <sxbld-analyze-variable-cons> rhs-symbol])
	sxbld-analyze-variable-prod-attributes(|rhs-symbol) =
		// Some attributes
		?attrs(_);
		sxbld-analyze-unsupported(|"Attributes not supported in variables section")

    /**
     * Generate a cons attribute for the metavariable containing the sort name
     *
     * The constructor name is <base language name>MetaVar<sort-name>.
     *
     * @type Sdf2Symbol -> Sdf2Attribute
     */
    sxbld-analyze-variable-cons:
    	sort(name) -> cons-attribute
    	where
    		<sxbld-env-get-base-language-name> () => base-language-name;
    		<conc-strings> (base-language-name, "MetaVar", name) => cons-name;
    		<sxbld-sdf2-cons-attribute> cons-name => cons-attribute

    /**
     * Analyzes a sorts section
     *
     * @type Grammar -> Grammar
     */
    sxbld-analyze-sorts =
        ?'sorts(symbols);
    	<map(sxbld-analyze-symbol)> symbols => analyzed-symbols;
   	    !'sorts(analyzed-symbols)

    /**
     * Checks for unsupported sort declarations
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    sxbld-analyze-symbol =
    	?sort(_) <+
    	sxbld-analyze-unsupported(|"Unsupported sort declaration")

    /**
     * Analyzes a sort name
     *
     * The sort name is added as SXAbsUnknownSort() to the environment
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
	// sxbld-analyze-symbol-sort =
	// 	?symbol@sort(name);
	// 	<sxbld-add-sort> (name, SXAbsSortUnknown());
	// 	!symbol

    /**
     * Succeeds if two sorts are equal, fails otherwise
     *
     * SXAbsSortUnknown() is equal to any sort.
     *
     * @type (SXAbsSort, SXAbsSort) -> (SXAbsSort, SXAbsSort)
     */
    sxbld-sorts-equal =
   		// ?(SXAbsSortUnknown(), _) +
   		// ?(_, SXAbsSortUnknown()) +
   		?(SXAbsSortLexical(), SXAbsSortLexical()) +
   		?(SXAbsSortContextFree(), SXAbsSortContextFree())

    /**
     * Adds a sort to the environment
     *
     * If a sort of the same name is already defined the two
     * sorts must be equal, otherwise the analysis fails.
     * If the previously defined sort is
     * SXAbsSortUnknown() it is updated by the new sort.
     *
     * @type (String, SXAbsSort) -> SXEnv
     */
    sxbld-add-sort =
    	?(name, sort);
    	<sxbld-env-get-sort> name;
    	if ?None() then
    		<sxbld-env-add-sort> (name, sort)
    	else
    		?Some(other-sort);
    		if <sxbld-sorts-equal> (sort, other-sort) then
    			<sxbld-get-env-hashtable> ()
    			// <sxbld-add-sort-unless-unknown> (name, sort)
    		else
    			<sxbld-analyze-fail(|"Invalid redeclaration of sort")> name
    		end
    	end

    /**
      * Adds a sort to the environment only if its not SXAbsSortUnknown()
      *
      * @type (String, SXAbsSort) -> SXEnv
      */
    // sxbld-add-sort-unless-unknown =
    // 	(?(name, SXAbsSortUnknown()); sxbld-get-env-hashtable) <+ // Return the environment in any case
    // 	(?(name, sort); sxbld-env-add-sort)

    sxbld-analyze-add-arity =
    	?(cons-name-quoted, arity);
    	<un-double-quote> cons-name-quoted => cons-name;
    	<sxbld-env-get-arity> cons-name;
    	if ?None() then
    		<sxbld-env-add-arity> (cons-name, arity)
    	else
    		<sxbld-analyze-fail(|"Duplicate constructor name")> cons-name-quoted
    	end

    /**
     * Analyzes a context-free syntax section
     *
     * @type Grammar -> Gramar
     */
    sxbld-analyze-cf-syntax =
    	?context-free-syntax(prods);
    	<map(sxbld-analyze-cf-production)> prods => analyzed-prods;
        !context-free-syntax(analyzed-prods)

    /**
     * Analyzes a context-free production
     *
     * @type Sdf2Production -> Sdf2Production
     */
    sxbld-analyze-cf-production =
    	?prod(symbols, symbol, attributes);
    	<sxbld-analyze-cf-rhs> symbol => (analyzed-symbol, sort-name);
    	<sxbld-analyze-cf-attributes(|sort-name)> attributes => (analyzed-attributes, cons-name-quoted);
    	<sxbld-analyze-cf-lhs> symbols => sort-names;
    	<sxbld-analyze-add-arity> (cons-name-quoted, SXAbsArity(sort-names, sort-name));
    	!prod(symbols, analyzed-symbol, analyzed-attributes)

    sxbld-analyze-cf-lhs =
    	sxbld-analyze-cf-lhs-supported <+
    	sxbld-analyze-cf-lhs-unsupported

    sxbld-analyze-cf-lhs-supported:
    	[] -> []
    sxbld-analyze-cf-lhs-supported:
    	[lit(_)|symbols] -> sort-names
    	where
    		<sxbld-analyze-cf-lhs> symbols => sort-names
    sxbld-analyze-cf-lhs-supported:
    	[sort(name)|symbols] -> [name|sort-names]
    	where
    		<sxbld-analyze-cf-lhs> symbols => sort-names

    sxbld-analyze-cf-lhs-unsupported =
    	?[symbol|_];
    	<sxbld-analyze-unsupported(|"Unsupported symbol")> symbol

    /**
     * Checks attributes of context-free production
     *
     * Generates a constructor name if necessary, includes it in
     * the analyzed attributes and also returns it.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     *
     * @type Sdf2Attributes -> (Sdf2Attributes, String)
     */
    sxbld-analyze-cf-attributes(|sort-name) =
    	((?no-attrs(); ![]) +
    	 (?attrs(attrib-list); !attrib-list));
    	sxbld-analyze-cf-attribute-list-cons(|sort-name) => (attrib-list-with-cons, cons-name);
    	!(attrs(attrib-list-with-cons), cons-name)

    
    /**
     * Adds or prefixes a cons attribute
     *
     * It returns the new attribute list and the name of the constructor.
     * If a constructor name is given in an attribut the exact string from
     * the input is returned. Therefore, the constructor name is double-qouted.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     * @type List(Sdf2Attribute) -> (List(Sdf2Attribute, String))
     */
    sxbld-analyze-cf-attribute-list-cons(|sort-name) =
    	partition(sxbld-sdf2-is-attribute(|"cons")) => (cons-attribs, other-attribs);
    	((// No cons attribute, generate one
    	  !cons-attribs; ?[];
    	  <sxbld-env-fresh-cons-name> sort-name => cons-name;
    	  <double-quote> cons-name => cons-name-quoted;
    	  <sxbld-env-prefix-name> cons-name => cons-name-prefixed;
    	  !([<sxbld-sdf2-cons-attribute> cons-name-prefixed | other-attribs], cons-name-quoted)) <+
    	 (// One cons attribute, prefix it
    	  !cons-attribs; ?[cons-attrib];
    	  <sxbld-sdf2-cons-attribute-name-quoted> cons-attrib => cons-name-quoted;
    	  <un-double-quote; sxbld-env-prefix-name> cons-name-quoted => prefixed-cons-name;
    	  !([<sxbld-sdf2-cons-attribute> prefixed-cons-name | other-attribs], cons-name-quoted)) <+
    	 (// More than one cons attribute, error
    	  <map(sxbld-analyze-fail(|"Several cons attributes are not allowed"))> cons-attribs))
        
    /**
     * Analyzes the right-hand side of a context-free production
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    sxbld-analyze-cf-rhs =
    	sxbld-analyze-cf-rhs-sort <+
    	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Adds the right-hand side sort as SXAbsSortContextFree() to environment
     *
     * @type Symbol -> SXEnv
     */
    sxbld-analyze-cf-rhs-sort =
    	?symbol@sort(name);
    	<sxbld-add-sort> (name, SXAbsSortContextFree());
    	!(symbol, name)

    /**
     * Analyzes a lexical syntax section
     *
     * @type Grammar -> Gramar
     */
    sxbld-analyze-lex-syntax =
    	?lexical-syntax(prods);
    	<map(sxbld-analyze-lex-production)> prods => analyzed-prods;
        !lexical-syntax(analyzed-prods)

    /**
     * Analyzes a lexical production
     *
     * @type Sdf2Production -> Sdf2Production
     */
    sxbld-analyze-lex-production =
    	?prod(symbols, symbol, attributes);
    	<sxbld-analyze-lex-rhs> symbol => (analyzed-symbol, sort-name);
    	!prod(symbols, analyzed-symbol, attributes)

    /**
     * Analyzes the right-hand side of a lexical production
     *
     * @type Sdf2Symbol -> Sdf2Symbol
     */
    sxbld-analyze-lex-rhs =
    	sxbld-analyze-lex-rhs-sort <+
    	sxbld-analyze-unsupported(|"Unsupported right-hand side")

    /**
     * Adds the right-hand side sort as SXAbsSortLexical() to environment
     *
     * @type Symbol -> SXEnv
     */
    sxbld-analyze-lex-rhs-sort =
    	?symbol@sort(name);
    	<sxbld-add-sort> (name, SXAbsSortLexical());
    	!(symbol, name)
   
    /**
     * Renames all sorts in the grammars and adds them to the environment
     *
     * @type SXBldGrammarElems -> SXEnv
     */   
    sxbld-desugar-grammar-elems =
    	?SXBldGrammarElems(grammars);
    	<sxbld-rename-all-sorts> grammars => renamed-grammars;
    	<map(\grm -> grammar-elem(grm)\)> renamed-grammars => grammar-elems;
    	<sxbld-env-add-grammar-elems> grammar-elems
