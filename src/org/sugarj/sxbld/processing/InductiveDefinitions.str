/**
 * Processing of inductive definitions
 */
module org/sugarj/sxbld/processing/InductiveDefinitions

imports org/sugarj/languages/SXBld

imports org/sugarj/sxbld/Environment
 	    org/sugarj/sxbld/Analysis

imports org/sugarj/soundx/InductiveDefinitions
		org/sugarj/soundx/AbstractSyntax

/**
 * Register analyses and desugarings
 */
strategies
	sxbld-desugar-to-env = sxbld-desugar-inductive-definitions
	sxbld-start-analysis = sxbld-analyze-inductive-definitions

/**
 * Analysis
 */
strategies
	sxbld-analyze-inductive-definitions =
		where(SXInductiveDefinitions(map(sxbld-analyze-inference-rule)))

	sxbld-analyze-inference-rule =
		?SXNamedInferenceRule(name, rule);
		<sxbld-analyze-wf-inf-rule; sxbld-meta-var-to-sx-metavar> rule => analyzed-rule;
		<sxbld-analyze-add-inference-rule> (name, analyzed-rule)

    sxbld-meta-var-to-sx-metavar =
    	topdown(try(\meta-var(name) -> SXMetaVar(name)\))

    // TODO: none of these ill-forms can appear for syntactically correct input.
    // Should we just use SDF2 variables "as is" without encoding the sort?
	sxbld-analyze-wf-inf-rule =
		?SXInferenceRule(premises, _, concl);
		<collect-all(sxbld-analyze-is-judgement, conc)> premises => premises-list;
		!SXAbsInfRule(premises-list, concl) //;
		// sxbld-analyze-wf-inf-rule

	sxbld-analyze-wf-inf-rule =
		?SXAbsInfRule(premises, concl);
		where(<map(sxbld-analyze-wf-judgement)> [concl|premises])
		
	sxbld-analyze-wf-judgement =
		?judg@c#(args);
		<sxbld-env-unprefix-name> c => judgement-name;
		<sxbld-env-get-form> judgement-name => Some(SXAbsJudgementForm(declared-sorts));
		(<zip> (args, declared-sorts) <+
		 <sxbld-analyze-fail(|"Wrong number of arguments")> judg);
		map(sxbld-analyze-wf-exprs)

    sxbld-analyze-wf-exprs =
    	?(expr, expected-sort);
    	!expr; ?c#(args);
    	<sxbld-env-unprefix-name> c => cons-name;
    	if <sxbld-analyze-is-metavar> cons-name then
    		<sxbld-analyze-metavar-sort> cons-name
    	else
    		<sxbld-env-get-arity> cons-name => Some(SXAbsArity(arg-sorts, res-sort));
    		(// Compare expected and actual sort
    		 (!expected-sort; ?res-sort) <+
    		 (<conc-strings> ("Expected sort ", expected-sort, " but found ", res-sort) => error-message;
    		  <sxbld-analyze-fail(|error-message)> expr));
    		// Check subexpressions
    		(<zip> (args, arg-sorts) <+
    		 <sxbld-analyze-fail(|"Wrong number of arguments")> expr);
    		map(sxbld-analyze-wf-exprs)
    	end

	sxbld-analyze-is-metavar =
		string-starts-with(|"SXMetaVar")
		
	sxbld-analyze-metavar-sort =
		explode-string;
		drop(|9); // Drop SXMetaVar prefix
		implode-string

	/**
	 * Checks if term is a judgement
	 *
	 * A judgement has a constructor named
	 * <base language name>Judgement<number>
	 *
	 * @type a -> a
	 */
	sxbld-analyze-is-judgement =
		?c#(_); where(<string-starts-with(|"SXJudgement")> c) +
		?SXNeq(_, _)
	
	sxbld-analyze-add-inference-rule =
		?(name, rule);
		<sxbld-env-get-inference-rule> name;
		if ?None() then
			<sxbld-env-add-inference-rule> (name, rule)
		else
			<sxbld-analyze-fail(|"Duplicate inference rule name")> name
		end

/**
 * Desugaring
 */
strategies
	sxbld-desugar-inductive-definitions =
		?SXInductiveDefinitions(_)
