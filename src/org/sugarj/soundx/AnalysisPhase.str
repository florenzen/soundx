/**
 * SoundX analysis phase: building the derivation
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/AnalysisPhase

imports org/sugarj/stdlib/StdTrans

imports org/sugarj/soundx/AbstractSyntax
        org/sugarj/soundx/Environment
        org/sugarj/soundx/Substitution
        org/sugarj/soundx/Resolution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/Unification

/**
 * Hook analysis into SugarJ
 */
strategies
	start-analysis = changed-tree-or-analysis-data(sx-analysis)

strategies
	/**
	 * The main SoundX analysis
	 */
	sx-analysis =
		?SXFinished(decls) < !SXFinished(decls) +
		(sx-env-add-toplevel-declaration;
		 if sx-is-last-toplevel-decl then
		 	 sx-env-get-toplevel-declarations;
		 	 sx-list-to-toplevel-decls => toplevel-decs;
		 	 sx-context-analysis;
		 	 
		 	 
		 	 !SXFinished(toplevel-decs);
		 	 // DEVEL
		 	 where(
		 	//  	<sx-sub-singleton> (SXMetaVar("a"), "String") => sub;
		 	//   	<sx-sub-map(\ _ -> 1 \)> sub => sub1;
		 	//   	<hashtable-getlist; debug(!"SUB  ")> sub;
		 	//   	<hashtable-getlist; debug(!"SUB1 ")> sub1;
		 	//   	<sx-sub-apply; debug(!"SUB APPLY ")> (sub1, [[[SXMetaVarGen("b", 17), SXMetaVar("b"),SXMetaVar("a"), SXMetaVar("a")],[]],SXMetaVar("a"), [4, SXMetaVar("a"), SXMetaVar("b")]]);
		 	//   	<hashtable-init> [(SXMetaVar("c"), "5"), (SXMetaVar("b"), "1")]=> subA1;
		 	//   	//<hashtable-init> []=> subA2;
		 	//   	<hashtable-init> [(SXMetaVar("a"), "String"), (SXMetaVar("b"), "1")]=> subA2;
				// <hashtable-getlist> subA1; debug(!" subA1 ");
		 	//   	<hashtable-getlist> subA2; debug(!" subA2 ");
		 	//   	((<sx-sub-union> (subA1, subA2); hashtable-getlist) <+ !"FAILED") => subAmerged;
		 	//   	<debug(!"MERGED ")> subAmerged;
		 	//   	let folds(|v,e) =
		 	//   		{acc: ?acc; ![(v,e)|acc]}
		 	//   	in
		 	//   	<hashtable-fold(folds|[])> subA1; debug(!"AS EQS ")
		 	//   	end;
		 	//   	<sx-res-sub-to-eqs> subA1; debug(!"SUB TO EQS ");
		 	//   	![SXNeq("a", "b"), SXNeq(SXMetaVar("foo"), SXMetaVarGen("bar", 1)), SXNeq("a", SXMetaVar("baz"))];
		 	//   	sx-res-assign-neqs; debug(!"ASSIGN ")
		 	id
		 	//sx-inference-rules; debug(!"Inference rules ");
		 	//sx-interface-judgement; debug(!"Interface judgement")
		 	 )
		 else
		 	 ![]
		 end)

strategies
	sx-context-analysis =
		?toplevel-decls;
		sx-inference-rules => inf-rules;
		sx-interface-judgement => (tlds-pattern, intf-pattern, judg);
		//<sx-vars> tlds-pattern => vars-tlds;
		//<sx-unify(|vars-tlds)> (tlds-pattern, toplevel-decls) => result;
		//!result; not(?SXUnificationFailure(_));
		//<sx-sub-apply> (result, judg) => goal;
		//debug(!"GOAL ");
		!SXJudgement4(SXCons2(), STLCNat("1"), SXMetaVar("U")) => goal1;
		debug(!"GOAL");
		<sx-res-build-derivation> ([], inf-rules, goal1) => result-deriv;
		debug(!"RESULT")

signature constructors
	SXJudgement4: a * a * a -> a
	SXCons2:  a
	STLCNat: a -> a

strategies
	/**
 	 * Checks if the current toplevel declaration is the last one
 	 */
	sx-is-last-toplevel-decl =
		prim("SUGARJ_is_last_toplevel_declaration")
