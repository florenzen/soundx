/**
 * SoundX analysis phase: building the derivation
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/AnalysisPhase

imports org/sugarj/stdlib/StdTrans

imports org/sugarj/soundx/AbstractSyntax
        org/sugarj/soundx/Environment
        org/sugarj/soundx/Substitution
        org/sugarj/soundx/Resolution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/Unification
		org/sugarj/soundx/DepthFirstBC
		org/sugarj/soundx/ExtensionDefinition
		org/sugarj/soundx/InductiveDefinitions
		org/sugarj/soundx/AnalysisFunctions
		org/sugarj/soundx/Utils


imports org/sugarj/soundx/Debug

imports org/sugarj/soundx/processing/GrammarElems
		org/sugarj/soundx/processing/Namespace
		org/sugarj/soundx/processing/Import
		org/sugarj/soundx/processing/InductiveDefinitions
		org/sugarj/soundx/processing/Desugarings

imports org/sugarj/languages/Sdf2 // DEVEL


/**
 * Hook analysis into SugarJ
 */
strategies
	/**
     * Collects all errors from the annotation all-errors
     *
     * @type a -> List((a, String))
     */
	constraint-error =
		?ast;
		(<get-analysis-data(|"all-errors")> ast <+ ![])


	start-analysis = sx-analysis-unless-failed(changed-tree-or-analysis-data(sx-analysis))

	/**
	 * Analyzes a term unless the failed flag is set
	 *
	 * @type a -> SXBldFinishedAnalysis(a)
	 */
	sx-analysis-unless-failed(s) =
		where(<sx-env-get-failed> () => SXFalse()); s

/**
 * The main SoundX analysis
 */
strategies
	// analysis never changes its input (apart from error annotations)
	sx-analysis =
		where(
			sx-debug(|"current toplevel declaration: ");
		 	sx-process-toplevel-declaration;
		 	if sx-is-last-toplevel-decl then
		 		<sx-debug(|"last toplevel declaration")> "";
		 	 	sx-env-get-toplevel-declarations;
		 	 	sx-debug(|"list of toplevel declarations");
		 	 	sx-list-to-toplevel-decls => toplevel-decs;
		 	 	sx-context-analysis
		 	 else
		 	 	id
		 	 end)
		 	 
		 	 
		 	 // DEVEL
		 	// where(
		 	//  	<sx-sub-singleton> (SXMetaVar("a"), "String") => sub;
		 	//   	<sx-sub-map(\ _ -> 1 \)> sub => sub1;
		 	//   	<hashtable-getlist; debug(!"SUB  ")> sub;
		 	//   	<hashtable-getlist; debug(!"SUB1 ")> sub1;
		 	//   	<sx-sub-apply; debug(!"SUB APPLY ")> (sub1, [[[SXMetaVarGen("b", 17), SXMetaVar("b"),SXMetaVar("a"), SXMetaVar("a")],[]],SXMetaVar("a"), [4, SXMetaVar("a"), SXMetaVar("b")]]);
		 	//   	<hashtable-init> [(SXMetaVar("c"), "5"), (SXMetaVar("b"), "1")]=> subA1;
		 	//   	//<hashtable-init> []=> subA2;
		 	//   	<hashtable-init> [(SXMetaVar("a"), "String"), (SXMetaVar("b"), "1")]=> subA2;
				// <hashtable-getlist> subA1; debug(!" subA1 ");
		 	//   	<hashtable-getlist> subA2; debug(!" subA2 ");
		 	//   	((<sx-sub-union> (subA1, subA2); hashtable-getlist) <+ !"FAILED") => subAmerged;
		 	//   	<debug(!"MERGED ")> subAmerged;
		 	//   	let folds(|v,e) =
		 	//   		{acc: ?acc; ![(v,e)|acc]}
		 	//   	in
		 	//   	<hashtable-fold(folds|[])> subA1; debug(!"AS EQS ")
		 	//   	end;
		 	//   	<sx-res-sub-to-eqs> subA1; debug(!"SUB TO EQS ");
		 	//   	![SXNeq("a", "b"), SXNeq(SXMetaVar("foo"), SXMetaVarGen("bar", 1)), SXNeq("a", SXMetaVar("baz"))];
		 	//   	sx-res-assign-neqs; debug(!"ASSIGN ")
		 	//id
		 	//sx-inference-rules; debug(!"Inference rules ");
		 	//sx-interface-judgement; debug(!"Interface judgement")
		 	// )
		 //else
		 	// fail
		 //end)

	
strategies
	sx-process-toplevel-declaration =
		sx-process-extension-begin +
		sx-process-extension-end +
		sx-process-grammar-elems +
		sx-process-desugarings +
		sx-process-inductive-defs +
		sx-process-namespace-decl +
		sx-process-import-decl +
		sx-process-body-decl

	sx-process-body-decl =
		?decl;
		sx-is-body-decl;
		if sx-env-is-extension-processing then
			<sx-analysis-fail(|"body declaration cannot be inside extension")> decl
		else
			<sx-env-add-toplevel-declaration> decl;
			<sx-debug(|"processsed body decl")> ""
		end
		
	sx-process-extension-begin =
		?decl@SXExtensionBegin(_);
		if sx-env-is-extension-processing then
			<sx-analysis-fail(|"extensions cannot be nested")> decl
		else
			sx-env-set-extension-processing;
			<sx-debug(|"switched extension processing on")> ""
		end
		
	sx-process-extension-end =
		?decl@SXExtensionEnd(_);
		if sx-env-is-extension-processing then
			sx-env-unset-extension-processing;
			<sx-debug(|"switched extension processing off")> ""
		else
			<sx-analysis-fail(|"extension end without extension begin")> decl
		end

	sx-process-grammar-elems =
		?SXGrammarElems(_)


strategies
	sx-context-analysis =
		?toplevel-decls;
		sx-inference-rules => inf-rules;
		sx-interface-judgement => (tlds-pattern, intf-pattern, judg);
		<sx-vars> tlds-pattern => vars-tlds;
		<sx-unify(|vars-tlds)> (tlds-pattern, toplevel-decls) => result;
		!result; not(?SXUnificationFailure(_));
		<sx-sub-apply> (result, judg) => goal;
		//!SXNeq("x", "y") => goal;
		//!SXJudgement4(SXCons2(), STLCNat("1"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons2(), STLCAdd(STLCNat("1"), STLCNat("1")), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons2(),"x",SXCons0()), STLCVar("x"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons3(SXCons2(), "x", SXCons0()), "y", SXCons0()), STLCVar("x"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons3(SXCons3(SXCons2(), "b", SXCons0()), "x", SXCons0()), "y", SXCons0()), STLCVar("a"), SXMetaVar("U")) => goal;
		//!SXJudgement13("a", SXCons2()) => goal;
		//!SXJudgement13("a", SXCons3(SXCons3(SXCons2(), "c", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement13("c", SXCons3(SXCons3(SXCons2(), "c", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons2(), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons2(),"c",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons3(SXCons2(),"c",SXCons0()),"d",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons3(SXCons2(),"c",SXCons0()),"a",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXMetaVar("C1"), SXCons3(SXCons2(), SXMetaVar("x"), SXMetaVar("T"))) => goal;
		//!SXJudgement4(SXCons2(), STLCAbs("x", SXCons0(), STLCVar("x")), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons2(), STLCApp(STLCAbs("x", SXCons0(), STLCVar("x")), STLCNat("2")), SXMetaVar("U")) => goal;
		debug(!"GOAL");
		if <sx-dfsbc-build-derivations(|[])> ([], inf-rules, [goal]) => (sub, result-deriv) then
			<debug(!"RESULT")> result-deriv
			//;<hashtable-getlist; debug(!"SUB ")> sub
		else
			debug(!"FAILED")
		end
		


signature constructors // DEVEL
	SXJudgement4: a * a * a -> a
	SXJudgement13: a * a -> a
	SXJudgement12: a * a * a -> a

	STLCApp: a * a -> a
	STLCAbs: a * a * a -> a
	SXCons2:  a
	STLCNat: a -> a
	STLCAdd: a * a -> a
	STLCVar: a -> a
	SXCons0: a
	SXCons3: a * a * a -> a




		// EXP w/ pp
		// !'module("foo", [], [
		// 	context-free-syntax([lit("a")],
		// 	sort("A"),attrs([term(default(appl(unquoted("cons"),
		// 	  [fun(quoted("\"A\""))])))]))]) => grammar;
		// <ppgenerate> grammar => pptable;
		// debug(!"PP TABLE ")



strategies
	//current-guard = fail
	

