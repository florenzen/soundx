/**
 * SoundX analysis phase: building the derivation
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/AnalysisPhase

imports org/sugarj/stdlib/StdTrans

imports org/sugarj/soundx/AbstractSyntax
        org/sugarj/soundx/Environment
        org/sugarj/soundx/Substitution
        org/sugarj/soundx/Resolution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/Unification
		org/sugarj/soundx/DepthFirstBC
		org/sugarj/soundx/ExtensionDefinition
		org/sugarj/soundx/InductiveDefinitions
		org/sugarj/soundx/AnalysisFunctions
		org/sugarj/soundx/Utils

imports org/sugarj/soundx/processing/GrammarElems
		org/sugarj/soundx/processing/Namespace
		org/sugarj/soundx/processing/Import
		org/sugarj/soundx/processing/InductiveDefinitions
		org/sugarj/soundx/processing/Desugarings

imports org/sugarj/soundx/Debug


/**
 * Hook analysis into SugarJ
 */
strategies
	/**
     * Collects all errors from the annotation all-errors
     *
     * @type a -> List((a, String))
     */
	constraint-error =
		?ast;
		(<get-analysis-data(|"all-errors")> ast <+ ![])

	/**
	 * Starts the SoundX analysis
	 *
	 * @type a -> a
	 */
	start-analysis = sx-analysis-unless-failed(changed-tree-or-analysis-data(sx-analysis))

	/**
	 * Analyzes a term with s unless the failed flag is set
	 *
	 * @param s a -> a
	 *
	 * @type a -> a
	 */
	sx-analysis-unless-failed(s) =
		where(<sx-env-get-failed> () => SXFalse()); s

/**
 * The main SoundX analysis
 */
strategies
	/**
	 * Runs the SoundX analysis
	 *
	 * It is intended to run once for each toplevel declaration.
	 * The toplevel declaration is processed depending on what kind of
	 * declaration it is. If the current declaration is the last toplevel
	 * declaration the context analysis is started.
	 *
	 * @type ToplevelDeclaration -> ToplevelDeclaration
	 */
	sx-analysis =
		// analysis never changes its input (apart from error annotations)
		where(
			sx-debug(|"current toplevel declaration: ");
		 	sx-process-toplevel-declaration;
		 	if sx-is-last-toplevel-decl then
		 		<sx-debug(|"last toplevel declaration")> "";
		 	 	sx-analysis-store-re-exports;
		 	 	sx-env-get-toplevel-declarations => toplevel-decs-list;
		 	 	sx-debug(|"list of toplevel declarations");
		 	 	<sx-list-to-toplevel-decls> toplevel-decs-list => toplevel-decs;
		 	 	<sx-context-analysis> toplevel-decs
		 	 	
		 	 else
		 	 	id
		 	 end)

	/**
	 * Stores the list of re-exports from the module's imports in the environment
	 *
	 * @type _ -> SXEnv
	 */
	sx-analysis-store-re-exports =
		sx-env-get-imports => imports;
		let map-s = {
			mod, re-exp:
				?mod;
				<sx-interface-re-exports> mod => re-exp;
				![mod|re-exp]
			}
		in
			<map(map-s); concat> imports => re-exports;
			<sx-nub> re-exports => re-exp-nub;
			<sx-env-set-re-exports> re-exp-nub
		end

	/**
	 * Performs the context analysis
	 *
	 * It sets up the interface judgement and tries to derive it
	 * using the rules from the base language and the imported extensions.
	 *
	 * It stores the module's interface and the derivation in the environment.
	 *
	 * If the interface judgement cannot be derived this strategy aborts
	 * the analysis phase with an error message stating that there are
	 * context errors.
	 *
	 * TODO: integrate some error investigation procedure here.
	 *
	 * @type SXToplevelDeclarations -> SXEnv
	 */
	sx-context-analysis =
		?toplevel-decls@SXToplevelDeclarationsCons(head, tail);
		// fetch all inference rules
		sx-inference-rules => inf-rules-base;
		sx-inference-rules-from-extensions => inf-rules-extensions;
		<map(sx-inf-rule-name); sx-debug(|"inference rules from extesions ")> inf-rules-extensions;
		<conc> (inf-rules-base, inf-rules-extensions) => inf-rules;
		// set up the interface judgement
		sx-interface-judgement => (tlds-pattern, intf-pattern, judg);
		<sx-vars> tlds-pattern => vars-tlds;
		<sx-unify(|vars-tlds)> (tlds-pattern, toplevel-decls) => result;
		if !result; ?SXUnificationFailure(msg) then
			// if the tlds pattern cannot be matched with the input program
			// this is a defect of the base language definition
			<conc-strings> ("could not instantiate interface judgement (", msg, ").",
				"This is a defect in the base language definition") => message;
			<sx-analysis-fail(|message)> head
		else
			<sx-sub-apply> (result, judg) => goal;
			<sx-debug(|"interface goal ")> goal;
			// derive the interface judgement and store the module's interface
			// and the derivation for later desugaring in the environment
			if <sx-dfsbc-build-derivations(|[])> ([], inf-rules, [goal]) => (sub, result-deriv) then
				<sx-sub-apply> (sub, intf-pattern) => interface;				
				<sx-debug(|"interface of module ")> interface;
				<sx-env-set-interface> interface;
				<sx-env-set-derivation> result-deriv
			else
				!"The module contains context errors (error investigation is not yet implemented)" => message;
				<sx-analysis-fail(|message)> head
			end
		end

	/**
	 * Returns a list of inference rules from the imported extensions
	 *
	 * @type _ -> List(SXInfRule)
	 */
	sx-inference-rules-from-extensions =
		sx-env-get-re-exports; mapconcat(sx-extension-inference-rules)

/**
 * Processing of toplevel declarations
 */
strategies
	/**
	 * Processes all supported toplevel declarations
	 *
	 * @type ToplevelDeclaration-> SXEnv
	 */
	sx-process-toplevel-declaration =
		sx-process-extension-begin +
		sx-process-extension-end +
		sx-process-grammar-elems +
		sx-process-desugarings +
		sx-process-inductive-defs +
		sx-process-namespace-decl +
		sx-process-import-decl +
		sx-process-body-decl

	/**
	 * Processes a body declaration
	 *
	 * The strategy aborts with an error if the body declaration is inside
	 * an extension definition, otherwise it is stored in the environment.
	 *
	 * @type ToplevelDeclaration -> SXEnv
	 */
	sx-process-body-decl =
		?decl;
		sx-is-body-decl;
		if sx-env-is-extension-processing then
			<sx-analysis-fail(|"body declaration cannot be inside an extension definition")> decl
		else
			<sx-env-add-toplevel-declaration> decl;
			<sx-debug(|"processsed body decl")> ""
		end

	/**
	 * Processes the begin marker of an extension definition
	 *
	 * This strategy aborts with an error if extension processing is
	 * currently on. Otherwise, extension processing is switched to on
	 *
	 * @type ToplevelDeclaration -> SXEnv
	 */
	sx-process-extension-begin =
		?decl@SXExtensionBegin(_);
		if sx-env-is-extension-processing then
			<sx-analysis-fail(|"extensions cannot be nested")> decl
		else
			sx-env-set-extension-processing;
			<sx-debug(|"switched extension processing on")> ""
		end

	/**
	 * Processes the end marker of an extension definition
	 *
	 * This strategy fails if extension processing is off. Otherwise,
	 * extension processing is switched to off.
	 *
	 * @type ToplevelDeclaration -> SXEnv
	 */
	sx-process-extension-end =
		?decl@SXExtensionEnd(_);
		if sx-env-is-extension-processing then
			sx-env-unset-extension-processing;
			<sx-debug(|"switched extension processing off")> ""
		else
			<sx-analysis-fail(|"extension end without extension begin")> decl
		end
