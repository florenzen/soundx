/**
 * SoundX analysis phase: building the derivation
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/AnalysisPhase

imports org/sugarj/stdlib/StdTrans

imports org/sugarj/soundx/AbstractSyntax
        org/sugarj/soundx/Environment
        org/sugarj/soundx/Substitution
        org/sugarj/soundx/Resolution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/Unification

imports org/sugarj/languages/Sdf2 // DEVEL

/**
 * Hook analysis into SugarJ
 */
strategies
	start-analysis = changed-tree-or-analysis-data(sx-analysis)

strategies
	/**
	 * The main SoundX analysis
	 */
	sx-analysis =
		?SXFinished(decls) < !SXFinished(decls) +
		(debug(!"CURRENT TOPLEVEL DECL ");
		 sx-env-add-toplevel-declaration;
		 if sx-is-last-toplevel-decl then
		 	 sx-env-get-toplevel-declarations;
		 	 debug(!"LIST OF TOPLEVEL DECLARATIONS ");
		 	 sx-list-to-toplevel-decls => toplevel-decs;
		 	 sx-context-analysis;
		 	 
		 	 
		 	 !SXFinished(toplevel-decs);
		 	 // DEVEL
		 	 where(
		 	//  	<sx-sub-singleton> (SXMetaVar("a"), "String") => sub;
		 	//   	<sx-sub-map(\ _ -> 1 \)> sub => sub1;
		 	//   	<hashtable-getlist; debug(!"SUB  ")> sub;
		 	//   	<hashtable-getlist; debug(!"SUB1 ")> sub1;
		 	//   	<sx-sub-apply; debug(!"SUB APPLY ")> (sub1, [[[SXMetaVarGen("b", 17), SXMetaVar("b"),SXMetaVar("a"), SXMetaVar("a")],[]],SXMetaVar("a"), [4, SXMetaVar("a"), SXMetaVar("b")]]);
		 	//   	<hashtable-init> [(SXMetaVar("c"), "5"), (SXMetaVar("b"), "1")]=> subA1;
		 	//   	//<hashtable-init> []=> subA2;
		 	//   	<hashtable-init> [(SXMetaVar("a"), "String"), (SXMetaVar("b"), "1")]=> subA2;
				// <hashtable-getlist> subA1; debug(!" subA1 ");
		 	//   	<hashtable-getlist> subA2; debug(!" subA2 ");
		 	//   	((<sx-sub-union> (subA1, subA2); hashtable-getlist) <+ !"FAILED") => subAmerged;
		 	//   	<debug(!"MERGED ")> subAmerged;
		 	//   	let folds(|v,e) =
		 	//   		{acc: ?acc; ![(v,e)|acc]}
		 	//   	in
		 	//   	<hashtable-fold(folds|[])> subA1; debug(!"AS EQS ")
		 	//   	end;
		 	//   	<sx-res-sub-to-eqs> subA1; debug(!"SUB TO EQS ");
		 	//   	![SXNeq("a", "b"), SXNeq(SXMetaVar("foo"), SXMetaVarGen("bar", 1)), SXNeq("a", SXMetaVar("baz"))];
		 	//   	sx-res-assign-neqs; debug(!"ASSIGN ")
		 	id
		 	//sx-inference-rules; debug(!"Inference rules ");
		 	//sx-interface-judgement; debug(!"Interface judgement")
		 	 )
		 else
		 	 fail
		 end)

strategies
	sx-context-analysis =
		?toplevel-decls;
		sx-inference-rules => inf-rules;
		sx-interface-judgement => (tlds-pattern, intf-pattern, judg);
		<sx-vars> tlds-pattern => vars-tlds;
		<sx-unify(|vars-tlds)> (tlds-pattern, toplevel-decls) => result;
		!result; not(?SXUnificationFailure(_));
		//<sx-sub-apply> (result, judg) => goal;
		//!SXJudgement4(SXCons2(), STLCNat("1"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons2(), STLCAdd(STLCNat("1"), STLCNat("1")), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons2(),"x",SXCons0()), STLCVar("x"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons3(SXCons2(), "x", SXCons0()), "y", SXCons0()), STLCVar("x"), SXMetaVar("U")) => goal;
		//!SXJudgement4(SXCons3(SXCons3(SXCons3(SXCons2(), "b", SXCons0()), "x", SXCons0()), "y", SXCons0()), STLCVar("a"), SXMetaVar("U")) => goal;
		//!SXJudgement13("a", SXCons2()) => goal;
		//!SXJudgement13("a", SXCons3(SXCons3(SXCons2(), "c", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement13("c", SXCons3(SXCons3(SXCons2(), "c", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons2(), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons2(),"c",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons3(SXCons2(),"c",SXCons0()),"d",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		//!SXJudgement12(SXMetaVar("C"), SXCons3(SXCons3(SXCons2(),"c",SXCons0()),"a",SXCons0()), SXCons3(SXCons3(SXCons2(), "a", SXCons0()), "b", SXCons0())) => goal;
		!SXJudgement12(SXMetaVar("C"), SXMetaVar("C1"), SXCons3(SXCons2(), SXMetaVar("x"), SXMetaVar("T"))) => goal;
		debug(!"GOAL");
		<sx-res-build-derivation> ([], inf-rules, goal) => result-deriv;
		debug(!"RESULT")
		


signature constructors // DEVEL
	SXJudgement4: a * a * a -> a
	SXJudgement13: a * a -> a
	SXJudgement12: a * a * a -> a

	SXCons2:  a
	STLCNat: a -> a
	STLCAdd: a * a -> a
	STLCVar: a -> a
	SXCons0: a
	SXCons3: a * a * a -> a
strategies
	/**
 	 * Checks if the current toplevel declaration is the last one
 	 */
	sx-is-last-toplevel-decl =
		prim("SUGARJ_is_last_toplevel_declaration")



		// EXP w/ pp
		// !'module("foo", [], [
		// 	context-free-syntax([lit("a")],
		// 	sort("A"),attrs([term(default(appl(unquoted("cons"),
		// 	  [fun(quoted("\"A\""))])))]))]) => grammar;
		// <ppgenerate> grammar => pptable;
		// debug(!"PP TABLE ")
