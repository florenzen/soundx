/*
 * Copyright (c) 2015, TU Berlin
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 * - Neither the name of the TU Berlin nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Generation of fresh atoms
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/FreshAtoms

imports org/sugarj/soundx/Declarations
		org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Substitution
		org/sugarj/soundx/DepthFirstBC
		org/sugarj/soundx/AnalysisPhase

imports org/sugarj/soundx/Debug


strategies
	sx-fresh-atom-replace-all =
		bottomup(try(sx-fresh-atom-generator))

	sx-fresh-atom-generator =
		?cons#(args);
		<string-starts-with(|"SXFreshFun")> cons;
		<sx-debug(|"fresh atom generator found ")> cons#(args);
		<sx-fresh-extract-sort-name> cons => sort-name;
		sx-debug(|"fresh atom for sort ");
		sx-freshness-conditions => freshness-conds;
		<lookup> (sort-name, freshness-conds) => freshness-cond;
		sx-debug(|"extracted freshness conds ");
		<sx-fresh-atom> (freshness-cond, args)
		;sx-debug(|"generated ")

	sx-fresh-atom =
		sx-fresh-atom(|0)
		
	sx-fresh-atom(|count) =
		?(freshness-cond, args);
		<int-to-string> count => num;
		<conc-strings> (<sx-fresh-atom-prefix> (), num) => cand;
		<sx-debug(|"atom generator tries ")> cand;
		if <sx-fresh-atom-ok(|freshness-cond, args)> cand then
			!cand
		else
			<sx-fresh-atom(|<add> (count, 1))> (freshness-cond, args)
		end

	sx-fresh-atom-ok(|freshness-cond, args) =
		?cand;
		<map(sx-fresh-atom-ok(|freshness-cond, cand))> args
			
	sx-fresh-atom-ok(|freshness-cond, cand) =
		?arg;
		!freshness-cond => (atom-name, sort-name, judg);
		<sx-sub-singleton> (SXMetaVar(atom-name), cand) => sub1;
		<sx-sub-singleton> (SXMetaVar(sort-name), arg) => sub2;
		<sx-sub-apply> (sub1, judg) => judg1;
		<sx-sub-apply> (sub2, judg1) => judg2;
		<sx-dfsbc-build-derivation> ([], <sx-inference-rules> (), judg2)
		
	sx-fresh-inference-rules =
		sx-inference-rules => inf-rules-base;
		sx-inference-rules-from-extensions => inf-rules-ext;
		<conc> (inf-rules-base, inf-rules-ext)
		
	sx-fresh-extract-sort-name =
		?cons;
		sx-debug(|"extract 1");
		<explode-string> cons => chars;
		sx-debug(|"extract 2");
		<drop(|10)> chars => tail; // drop SXFreshFun
		sx-debug(|"extract 3");
		<take-until(?'_')> tail => sort-chars;
		sx-debug(|"extract 4");
		<implode-string> sort-chars => sort-name
		;sx-debug(|"extract 5")

	sx-fresh-atom-prefix = !"gen"


// 	/**
// 	 * Generates atom fresh from list of atom starting with prefix.
// 	 *
// 	 * TODO: make prefix definable in base language definition
// 	 *
// 	 * @param prefix String
// 	 *
// 	 * @type List(String) -> String
// 	 */
// 	sx-fresh-atom =
// 		sx-fresh-atom(|"gen", 0)
// 
// 	/**
// 	 * Generates atom fresh from list of atoms starting with prefix and
// 	 * ending with suffix >= n.
// 	 *
// 	 * @param prefix String
// 	 * @param suffix Int
// 	 *
// 	 * @type List(String) -> String
// 	 */
// 	sx-fresh-atom(|prefix, n) =
// 		?atoms;
// 		<int-to-string> n => suffix;
// 		<conc-strings> (prefix, suffix) => candidate;
// 		if <elem> (candidate, atoms) then
// 			<sx-fresh-atom(|prefix, <add> (n, 1))> atoms
// 		else
// 			!candidate
// 		end
