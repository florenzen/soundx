/*
 * Copyright (c) 2015, TU Berlin
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above
 *   copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided
 *   with the distribution.
 * - Neither the name of the TU Berlin nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Depth-first search backward chaining that build a derivation
 *
 * If no derivation can be found for the goal judgement
 * the algorithm simply fails.
 *
 * Primitive judgements like inequality or concatenation of lexical
 * elements require their input arguments to be bound. That is, it works
 * similar to Prolog arithmetics.
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/DepthFirstBC

imports org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Unification
		org/sugarj/soundx/Substitution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/FreshAtoms

imports org/sugarj/soundx/Debug


strategies
	sx-dfsbc-build-derivation =
		?(asms, inf-rules, judg);
		<sx-vars> asms => vars-asms;
		<sx-dfsbc-build-derivations(|vars-asms)> (asms, inf-rules, [judg]) => (_, [deriv]);
		!deriv

	sx-dfsbc-build-derivations(|vars-asms) =
		?(asms, inf-rules, []);
		!(<sx-sub-empty> (), [])
	sx-dfsbc-build-derivations(|vars-asms) =
		?(asms, inf-rules, goals@[judg|_]);
		<sx-debug(|"trying ")> goals;
		(<sx-dfsbc-build-derivations-by-asm(|vars-asms)> (asms, asms, inf-rules, goals) <+
		 (<sx-is-prim-judgement> judg;
		  <sx-dfsbc-build-derivations-by-prim(|vars-asms)> (asms, inf-rules, goals)) +
		  <sx-is-ind-def-judgement> judg;
		  // <sx-debug(|"ind def judg ")> "";
		  <sx-dfsbc-build-derivations-by-rule(|vars-asms)> (asms, inf-rules, inf-rules, goals))

	sx-dfsbc-build-derivations-by-asm(|vars-asms) =
		?(all-asms, [], inf-rules, goals);
		fail
	sx-dfsbc-build-derivations-by-asm(|vars-asms) =
		?(all-asms, [asm|asms], inf-rules, goals@[judg|judgs]);
		((<sx-dfsbc-unify(|vars-asms)> (judg, <sx-concl> asm) => mgu;
		  <sx-sub-apply> (mgu, judgs) => judgs1;
		  <sx-dfsbc-build-derivations(|vars-asms)> (all-asms, inf-rules, judgs1) => (sub, derivs);
		  <sx-sub-compose> (sub, mgu) => sub1;
		  !(sub1, [asm|derivs])) <+
		 <sx-dfsbc-build-derivations-by-asm(|vars-asms)> (all-asms, asms, inf-rules, goals))

	// Note: the rule names in the SXDerivInst nodes for a primitive judgement
	// must contain characters that are not allowed in rule names of inductive
	// definitions since the rule names of the base system are not prefixed.
	sx-dfsbc-build-derivations-by-prim(|vars-asms) =
		// inequality judgement
		?(asms, inf-rules, [judg@SXNeq(expr1, expr2) | judgs]);
		// both arguments must be bound to a ground expression
		<sx-vars> expr1 => [];
		<sx-vars> expr2 => [];
		not(<eq> (expr1, expr2));
		<sx-dfsbc-build-derivations(|vars-asms)> (asms, inf-rules, judgs) => (sub, derivs);
		!(sub, [SXDerivInst([], "=/=", judg) | derivs])
	sx-dfsbc-build-derivations-by-prim(|vars-asms) =
		// get interface judgement
		?(asms, inf-rules, [judg@SXGetInterface(var, mid) | judgs]);
		// first argument must be a metavariable, second one must be bound to a string
		<sx-is-metavar> var;
		<is-string> mid;
		<sx-interface-expr> mid => interface; // Get interface
		<sx-sub-singleton> (var, interface) => sub-intf;
		<sx-sub-apply> (sub-intf, judgs) => judgs1;
		<sx-dfsbc-build-derivations(|vars-asms)> (asms, inf-rules, judgs1) => (sub, derivs);
		<sx-sub-compose> (sub, sub-intf) => sub1;
		<sx-sub-apply> (sub1, judg) => judg1;
		!(sub1, [SXDerivInst([], "=interface()", judg1) | derivs])
	sx-dfsbc-build-derivations-by-prim(|vars-asms) =
		// fresh in judgement
		?(asms, inf-rules, [judg@SXFreshIn(expr1, expr2) | judgs]);
		// <sx-debug(|"fresh in judgement ")> judg;
		// second argument must be bound to a ground expression
		// <sx-debug(|"vars ")> (<sx-vars> expr2);
		<sx-vars> expr2 => [];
		// <sx-debug(|"befor atoms ")> "";
		<sx-atoms> expr2 => atom-list;
		<sx-debug(|"Atoms list ")> atom-list;
		(// metavariable
		 (!expr1; sx-is-metavar;
		  // <sx-debug(|"is metavar")> "";
		  <sx-fresh-atom> atom-list => fresh-atom;
		  <sx-sub-singleton> (expr1, fresh-atom) => sub-fresh;
		  !SXDerivInst([], "_notin_", SXFreshIn(fresh-atom, expr2)) => deriv
		 ) <+
		 // generate fresh atom (argument must be ground)
		 // (?SXFreshAtom(arg);
		 //  // <sx-debug(|"fresh atom ")> "";
		 //  <sx-vars> arg => [];
		 //  <sx-atoms> arg => arg-atom-list;
		 //  <subseteq> (atom-list, arg-atom-list);
		 //  <sx-sub-empty> () => sub-fresh;
		 //  !SXDerivInst([], "_notin_", judg) => deriv
		 // ) <+
		 // concrete atom
		 (<sx-debug(|"other (fixed atom)")> "";
		  <sx-vars> expr1 => [];
		  <sx-debug(|"no meta vars")> "";
		  not(<elem> (expr1, atom-list));
		  <sx-debug(|"not elem ")> "";
		  <sx-sub-empty> () => sub-fresh;
		  !SXDerivInst([], "_notin_", judg) => deriv;
		  <sx-debug(|"at end ")> ""
		 ));
		 <sx-sub-apply> (sub-fresh, judgs) => judgs1;
		 <sx-dfsbc-build-derivations(|vars-asms)> (asms, inf-rules, judgs1) => (sub, derivs);
		 <sx-sub-compose> (sub, sub-fresh) => sub1;
		 !(sub1, [deriv | derivs])
		 ;where(<sx-debug(|"at final end")> "")

	sx-dfsbc-build-derivations-by-rule(|vars-asms) =
		?(asms, all-inf-rules, [], goals);
		fail
	sx-dfsbc-build-derivations-by-rule(|vars-asms) =
		?(asms, all-inf-rules, [inf-rule|inf-rules], goals@[judg|judgs]);
		((<sx-fresh-inf-rule> inf-rule => SXInfRule(premises, name, concl);
		  <sx-dfsbc-unify(|vars-asms)> (judg, concl) => mgu;
		  <sx-debug(|"found matching rule w/ premises ")> premises;
		  <sx-sub-apply> (mgu, <conc> (premises, judgs)) => judgs1;
		  <sx-dfsbc-build-derivations(|vars-asms)> (asms, all-inf-rules, judgs1) => (sub, derivs);
		  <split-at(|<length> premises)> derivs => (derivs-prem, derivs-other);
		  <sx-sub-compose> (sub, mgu) => sub1;
		  <sx-sub-apply> (sub1, judg) => judg1;
		  !(sub1, [SXDerivInst(derivs-prem, name, judg1) | derivs-other])) <+
		 <sx-dfsbc-build-derivations-by-rule(|vars-asms)> (asms, all-inf-rules, inf-rules, goals))

	sx-dfsbc-unify(|vars-asms) =
		?(expr1, expr2);
		<sx-vars> (expr1, expr2) => vars-exprs;
		<diff> (vars-exprs, vars-asms) => vars-unify;
		<sx-unify(|vars-unify)> (expr1, expr2) => result;
		if !result; ?SXUnificationFailure(_) then
			fail
		else
			!result
		end
