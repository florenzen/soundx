/**
 * Processing of SDF2 sections
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/processing/GrammarElems

imports org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Environment
        org/sugarj/soundx/AnalysisFunctions
        org/sugarj/soundx/SDF2

imports org/sugarj/soundx/processing/Prefixing


/**
 * Analyses
 */
strategies
	/**
	 * Analyzes list of SDF2 sections
	 *
	 * Adds SDF2 sections as grammar elems to the environment
	 *
	 * @type SXBldGrammarElems -> SXBldGrammarElems
	 */
	sx-process-grammar-elems =
		?SXGrammarElems(grammars);
		where(
			<map(sx-process-grammar-elem); concat> grammars;
		    // Not using mapconcat here because it traverses the list from the end to front
		    // which lowers quality of error messages
			sx-add-grammar-elems)

    /**
     * Analyzes and transforms a single SDF2 section
     *
     * Gives an error on an unsupported section
     *
     * @type Grammar -> List(Grammar)
     */
    sx-process-grammar-elem =
        ((sx-process-sorts +
          sx-process-cf-syntax +
          sx-process-lex-syntax +
          sx-process-variables +
          sx-process-lex-priorities +
          sx-process-cf-priorities +
          sx-process-lex-restrictions +
          sx-process-cf-restrictions) <+
         sx-analysis-unsupported(|"Unsupported SDF 2 section"));
        (?[_|_] <+ ![<id>])

	// TODO: priorities must also be doubled like
	// productions

	/**
	 * Prefixes sorts in lexical priorities
	 *
	 * @type Grammar -> Grammar
	 */
	sx-process-lex-priorities =
		lexical-priorities(sx-prefix-all-sorts-base-lang)
	
   /**
	 * Prefixes sorts in context-free priorities
	 *
	 * @type Grammar -> Grammar
	 */
	sx-process-cf-priorities =
		context-free-priorities(sx-prefix-all-sorts-base-lang)

    /**
	 * Prefixes sorts in lexical restrictions
	 *
	 * @type Grammar -> Grammar
	 */
	sx-process-lex-restrictions =
		?lexical-restrictions(restr);
	    <sx-prefix-all-sorts(|"Gnd")> restr => restr-gnd;
		<conc; sx-prefix-all-sorts-base-lang> (restr, restr-gnd) => restr-prefixed;
	    !lexical-restrictions(restr-prefixed)

	/**
	 * Prefixes sorts in context-free restrictions
	 *
	 * @type Grammar -> Grammar
	 */
	sx-process-cf-restrictions =
		context-free-restrictions(sx-prefix-all-sorts-base-lang)

	/**
	 * Prefixes sorts in variables
	 *
	 * @type Grammar -> Grammar
	 */
	sx-process-variables =
	    variables(sx-prefix-all-sorts-base-lang)

    /**
     * Prefixes sorts in sorts
     *
     * @type Grammar -> Grammar
     */
    sx-process-sorts =
        'sorts(sx-prefix-all-sorts-base-lang)
    	// <map(sxbld-analyze-symbol); sxbld-prefix-all-sorts-base-lang> symbols => analyzed-symbols;
   	 //    !'sorts(analyzed-symbols)

    /**
     * Analyzes a context-free syntax section
     *
     * @type Grammar -> Grammar
     */
    sx-process-cf-syntax =
    	?context-free-syntax(prods);
    	<map(sx-process-cf-production); concat> prods => analyzed-prods;
        !context-free-syntax(analyzed-prods)

    /**
     * Analyzes a context-free production
     *
     * @type Sdf2Production -> Sdf2Production
     */
    sx-process-cf-production =
    	?prod(symbols, symbol, attributes);
    	<sx-process-cf-attributes> attributes => analyzed-attributes;
    	<sx-prefix-all-sorts-base-lang> symbol => prefixed-symbol;
    	<sx-prefix-all-sorts-base-lang> symbols => prefixed-symbols;
    	<sx-prefix-all-sorts(|"Gnd"); sx-prefix-all-sorts-base-lang> symbols => prefixed-ground-symbols;
    	<sx-prefix-all-sorts(|"Gnd"); sx-prefix-all-sorts-base-lang> symbol => prefixed-ground-symbol;
    	![prod(prefixed-symbols, prefixed-symbol, analyzed-attributes),
    	  prod(prefixed-ground-symbols, prefixed-ground-symbol, analyzed-attributes)]

    /**
     * Checks attributes of context-free production
     *
     * Generates a constructor name if necessary, includes it in
     * the analyzed attributes and also returns it.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     *
     * @type Sdf2Attributes -> Sdf2Attributes
     */
    sx-process-cf-attributes =
    	((?no-attrs(); ![]) +
    	 (?attrs(attrib-list); !attrib-list));
    	sx-process-cf-attribute-list-cons => attrib-list-with-cons;
    	!attrs(attrib-list-with-cons)

    /**
     * Adds or prefixes a cons attribute
     *
     * It returns the new attribute list and the name of the constructor.
     * If a constructor name is given in an attribut the exact string from
     * the input is returned. Therefore, the constructor name is double-qouted.
     *
     * A constructor is only returned if the attribute list does not contain a
     * bracket attribute.
     *
     * @param sort-name String name of the rhs sort to include in
     *   constructor name
     * @type List(Sdf2Attribute) -> List(Sdf2Attribute)
     */
    sx-process-cf-attribute-list-cons =
    	where(<elem> (bracket(), <id>)) <
    	// bracket attribute, return attributes untouched
    	id +
    	// No bracket attribute
    	(partition(sx-sdf2-is-attribute(|"cons")) => (cons-attribs, other-attribs);
    	 ((// No cons attribute, generate one
    	   !cons-attribs; ?[];
     	   sx-env-fresh-cons-name => cons-name;
     	   sx-env-add-cons-name;
    	   ![<sx-sdf2-cons-attribute> cons-name | other-attribs]) <+
    	  (// One cons attribute, prefix it
    	   !cons-attribs; ?[cons-attrib];
    	   <sx-sdf2-cons-attribute-name-quoted> cons-attrib => cons-name-quoted;
    	   <un-double-quote> cons-name-quoted => cons-name;
    	   <sx-prefix-name> cons-name => prefixed-cons-name;
		   if sx-env-cons-name-defined then
		   	   <sx-analysis-fail(|"Duplicate constructor name")> cons-name-quoted
		   else
		   	   <sx-env-add-cons-name> prefixed-cons-name;
    	       ![<sx-sdf2-cons-attribute> prefixed-cons-name | other-attribs]
    	   end) <+
    	  (// More than one cons attribute, error
    	   !cons-attribs; ?[_,_|_];
    	   <map(sx-analysis-fail(|"Several cons attributes are not allowed"))> cons-attribs)))

	/**
	 * Registers constructor and sort of body declaration if sx-body-dec attribute is given
	 *
	 * The attributes must contain a cons attribute.
	 *
	 * @type (Sdf2Symbol, Sdf2Attributes) -> (Sdf2Symbol, Sdf2Attributes)
	 */
	sx-process-body-dec =
		?(symbol, attributes);
		where(
			if <sxbld-sdf2-is-aterm-attribute-defined(|"sx-body-dec")> attributes then
				<sxbld-sdf2-extract-aterm-attribute(|"cons")> attributes => cons-attrib;
				<sxbld-sdf2-cons-attribute-name-quoted; un-double-quote> cons-attrib => cons-name;
				//<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => prefixed-symbol;
				<sxbld-env-add-body-dec> (cons-name, symbol)
			else
				id
			end)

	/**
	 * Registers constructor and sort of namespace declaration if sx-namespace-dec is given
	 *
	 * The attributes must contain a cons attribute.
	 *
	 * @type (Sdf2Symbols, Sdf2Symbol, Sdf2Attributes) -> (Sdf2Symbols, Sdf2Symbol, Sdf2Attributes)
	 */
	sxbld-analyze-namespace-dec =
		?(symbols, symbol, attributes);
		where(
			if <sxbld-sdf2-is-aterm-attribute-defined(|"sx-namespace-dec")> attributes then
				<sxbld-sdf2-extract-aterm-attribute(|"sx-namespace-dec")> attributes => namespace-attrib;
				if sxbld-env-is-namespace-dec-defined then
					<sxbld-analyze-fail(|"Only one `sx-namespace-dec' allowed")> namespace-attrib
				else
					<sxbld-sdf2-extract-aterm-attribute(|"cons")> attributes => cons-attrib;
					<sxbld-sdf2-cons-attribute-name-quoted; un-double-quote> cons-attrib => cons-name;
					<sxbld-sdf2-get-args-from-aterm-attribute> namespace-attrib => namespace-args;
					if ?[fun(unquoted(label))] then
						if <sxbld-sdf2-find-index-of-labelled-symbol(|label)> symbols => index then
							//<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => prefixed-symbol;
							<sxbld-env-set-namespace-dec> (cons-name, index, symbol)
						else
							<sxbld-analyze-fail(|"Label of `sx-namespace-dec' must be attached to symbol on lhs")> label
						end
					else
						<sxbld-analyze-fail(|"`sx-namespace-dec' takes exatcly one argument")> namespace-attrib
					end
				end
			else
				id
			end)

	/**
	 * Registers constructor and sort of import declaration if sx-import-dec is given
	 *
	 * The attributes must contain a cons attribute.
	 *
	 * @type (Sdf2Symbols, Sdf2Symbol, Sdf2Attributes) -> (Sdf2Symbols, Sdf2Symbol, Sdf2Attributes)
	 */
	sxbld-analyze-import-dec =
		?(symbols, symbol, attributes);
		where(
			if <sxbld-sdf2-is-aterm-attribute-defined(|"sx-import-dec")> attributes then
				<sxbld-sdf2-extract-aterm-attribute(|"sx-import-dec")> attributes => import-attrib;
				<sxbld-sdf2-extract-aterm-attribute(|"cons")> attributes => cons-attrib;
				<sxbld-sdf2-cons-attribute-name-quoted; un-double-quote> cons-attrib => cons-name;
				<sxbld-sdf2-get-args-from-aterm-attribute> import-attrib => import-args;
				if ?[fun(unquoted(label))] then
					if <sxbld-sdf2-find-index-of-labelled-symbol(|label)> symbols => index then
						//<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => prefixed-symbol;
						<sxbld-env-add-import-dec> (cons-name, index, symbol)
					else
						<sxbld-analyze-fail(|"Label of `sx-import-dec' must be attached to symbol on lhs")> label
					end
				else
					<sxbld-analyze-fail(|"`sx-import-dec' takes exatcly one argument")> import-attrib
				end
			else
				id
			end)

    /**
     * Analyzes a lexical syntax section
â€“     *
     * @type Grammar -> Gramar
     */
    sxbld-analyze-lex-syntax =
    	?lexical-syntax(prods);
    	<map(sxbld-analyze-lex-production); unzip; (concat, concat)> prods => (lex-prods, cf-prods);
        ![lexical-syntax(lex-prods), context-free-syntax(cf-prods)]

    /**
     * Analyzes a lexical production
     *
     * @type Sdf2Production -> (List(Sdf2Production), List(Sdf2Production))
     */
    sxbld-analyze-lex-production =
    	?prod(symbols, symbol, attributes);
    	<sxbld-prefix-all-sorts-base-lang> [symbol|symbols] => [prefixed-symbol|prefixed-symbols];
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbols => ground-symbols;
    	<sxbld-prefix-all-sorts(|"Gnd"); sxbld-prefix-all-sorts-base-lang> symbol => ground-symbol;
    	<sxbld-analyze-neq-judg> (attributes, prefixed-symbol) => cf-prods;
    	<sxbld-analyze-namespace-kind> (attributes, prefixed-symbol);
    	!([prod(prefixed-symbols, prefixed-symbol, attributes),
    	   prod(ground-symbols, ground-symbol, attributes)],
    	  cf-prods)

    /**
     * Generates inequality judgement for symbol if sx-requires-inequality is given
     *
     * @type (Sdf2Attributes, Sdf2Symbol) -> List(Sdf2Production)
     */
    sxbld-analyze-neq-judg =
    	?(attributes, symbol);
    	if <sxbld-sdf2-is-aterm-attribute-defined(|"sx-requires-inequality")> attributes then
    		![prod([symbol, lit("=/="), symbol], sort("SXJudgement"),
    	           attrs([<sxbld-sdf2-cons-attribute> "SXNeq"]))]
    	else
    		![]
    	end
    	    
    /**
     * Records the module identifier sort and namespace kind if sx-namespace-flat is given
     *
     * @type (Sdf2Attributes, Sdf2Symbol) -> (Sdf2Attributes, Sdf2Symbol)
     */
    sxbld-analyze-namespace-kind =
    	?(attributes, symbol);
    	where(
    		if <sxbld-sdf2-is-aterm-attribute-defined(|"sx-namespace-flat")> attributes then
    			if sxbld-env-is-namespace-kind-defined then
    				<sxbld-sdf2-extract-aterm-attribute(|"sx-namespace-flat")> attributes => attrib;
    				<sxbld-analyze-fail(|"Only one `sx-namespace' attribute allowed")> attrib
    			else
    				<sxbld-env-set-namespace-kind> SXBldNamespaceFlat();
    				<sxbld-env-set-namespace-identifier> symbol
    			end
    		else
				id
    		end)

    /**
     * Adds the grammars to the environment
     *
     * @type SXBldGrammarElems -> SXEnv
     */   
   sxbld-add-grammar-elems =
   	   map(\grm -> grammar-elem(grm)\);
   	   sxbld-env-add-grammar-elems
