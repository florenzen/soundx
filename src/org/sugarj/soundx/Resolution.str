/**
 * SoundX resolution procedure
 *
 * The procedure either return one valid derivation
 * or a list of invalid derivations containing error nodes.
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/Resolution

imports org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Unification
		org/sugarj/soundx/Substitution


/**
 * Derivation building
 */
strategies
	/**
	 * Builds a derivation given a list of assumptions, inference rules,
	 * and a goal judgement
	 *
	 * @type (List(SXDeriv), List(SXInfRule), SXJudgement) -> SXEither(List(SXDeriv), SXDeriv)
	 */
	sx-res-build-derivation =
		?(asms, inf-rules, judg);
		<sx-vars> asms => vars-asms;
		sx-res-empty-store => store;
		//debug(!"STORE ");
		<sx-res-derive-answers(|vars-asms)> (asms, inf-rules, store, judg) => answers;
		debug(!"ANSWERS DERIVED ");
		<map(sx-res-sub-variables(|vars-asms))> answers => answers1;
		debug(!"PREP ANSWERS");
		if !answers1; ?[(_, deriv)] then
			<sx-is-failure-deriv> deriv < !SXLeft(answers1) + !SXRight(deriv)
		else
			!SXLeft(answers1)
		end

	/**
	 * Derives a list of answers (pair of derivation and store) for a goal
	 *
	 * @param vars-asms List(SXMetaVar)
	 *
	 * @type (List(SXDeriv), List(SXInfRule), SXStore, SXJudgement) -> List(SXAnswer)
	 */
	//sx-res-derive-answers(|vars-asms) =
		// TODO SXGetInterface
		//fail
	sx-res-derive-answers(|vars-asms) =
		// Inequality judgement
		?(asms, inf-rules, store, judg@SXNeq(expr1, expr2));
		<sx-res-propagate(|vars-asms)> ([judg], store) => (ok, store1);
		if !ok; ?SXTrue() then
			![(store1, SXDerivInst([], "Neq", judg))]
		else
			![(store1, SXDerivFail(judg))]
		end => answers-constr;
		<sx-res-derive-by-asm(|vars-asms)> (asms, store, judg) => answers-asm;
		<sx-res-filter-answers> (<conc> (answers-constr, answers-asm))
	sx-res-derive-answers(|vars-asms) =
		// Inductively defined judgement
		?(asms, inf-rules, store, judg);
		<debug(!"GOAL ")> judg;
		<debug(!"WITH STORE ")> store;
		//<debug(!"STORE ")> store;
		<sx-is-ind-def-judgement> judg => (name, args);
		//debug(!"IS IND DEF JUDG ");
		<sx-res-possible-rules(|vars-asms)> (inf-rules, judg, store) => candidates;
		where(map(\(r,n,st)->(n)\); debug(!"POSSIBLE RULES "));
		//debug(!"POSSIBLE INF RULES");
		let map-s1 =
			{ premises, name, eqs, ok, store1, answers, inf-rules1:
				?(premises, name, eqs);
				<sx-res-push-back-rule> (name, inf-rules) => inf-rules1;
				<sx-res-propagate(|vars-asms)> (eqs, store) => (ok, store1);
				if !ok; ?SXTrue() then
					<debug(!"TRYING ")> name;
					<debug(!"WITH STORE ")> store1;
					let map-s2 =
						{ store3, deriv, store4:
							?(store3, derivs);
							<sx-res-remove-conflicting-neqs> store3 => store4;
							![(store4, SXDerivInst(derivs, name, judg))]
						}
					in
						let map-accum-s(|store2) =
							{ premise:
								?premise;
								<sx-res-derive-answers(|vars-asms)>
									(asms, inf-rules1, store2, premise) 
							}
						in
							<sx-mapconcat-accuml(map-accum-s|store1)> premises => answers;
							//debug(!"GOT ANSWERS ");
							<mapconcat(map-s2)> answers
							//;debug(!"GOT ANSWERS 2")
						end 
					end
					;where(<debug(!"FINISHED ")> name)
				else
					<debug(!"KICKED ")> name;
					![]
				end
				//;debug(!"MAP S1 RESULT ")
			}
		in
			<mapconcat(map-s1)> candidates
			//; debug(!"MAPC S1 RESULT")
		end => answers-inf-rules;
		//debug(!"ANSWERS IFN RULES");
		if !answers-inf-rules; ?[] then
			![(store, SXDerivFail(judg))]
		else
			!answers-inf-rules
		end => answers-inf-rules1;
		<sx-res-derive-by-asm(|vars-asms)> (asms, store, judg) => answers-asms;
		<sx-res-filter-answers> (<conc> (answers-inf-rules1, answers-asms))
		;debug(!"ANSWERS TOTAL")

	/**
	 * Moves the given inference to the front of the list
	 *
	 * Resolution tries inference rules from the end of the list,
	 * so putting it at the front pushes the rule to be tried again later.
	 *
	 * @type (String, List(SXInfRule)) -> List(InfRule)
	 */
	sx-res-push-back-rule =
		?(name, inf-rules);
		let move-front =
			{ name, rule, name1, inf-rules, inf-rules1, inf-rules-rest:
				?(name, [rule@SXInfRule(_, name1, _) | inf-rules], inf-rules1);
				if <eq> (name, name1) then
					<conc> (inf-rules, inf-rules1) => inf-rules-rest;
					![rule|inf-rules-rest]
				else
					<move-front> (name, inf-rules, [rule|inf-rules1])
				end
			}
		in
			<move-front> (name, inf-rules, [])
		end

	/**
	 * Tries to derive answers for a judgement using only the assumptions
	 *
	 * @param vars List(SXMetaVar)
	 *
	 * @type (List(SXDeriv), SXStore, SXJudgement) -> List(SXAnswer)
	 */
	sx-res-derive-by-asm(|vars-asms) =
		?(asms, store, judg);
		<sx-res-possible-assumptions(|vars-asms)> (asms, judg) => candidates;
		let map-s =
			{ deriv, eqs, ok, store1:
				?(deriv,eqs);
				<sx-res-propagate(|vars-asms)> (eqs, store) => (ok, store1);
				if !ok; ?SXTrue() then
					![(store1, deriv)]
				else
					![]
				end
			}
		in
			<mapconcat(map-s)> candidates
		end

	/**
	 * Finds assumptions that possible solve the goal judgement
	 *
	 * The result is a list of pairs of assumptions and constraints.
	 * The constraints must hold for the accompagnying assumption to
	 * possibly solve the goal.
	 *
	 * @param vars-asm List(SXMetaVars)
	 *
	 * @type (List(SXDeriv), SXJudgement) -> List((SXDeriv, SXStore))
	 */
	sx-res-possible-assumptions(|vars-asms) =
		?([], judg); ![]
	sx-res-possible-assumptions(|vars-asms) =
		?([deriv|derivs], judg);
		<diff> (<sx-vars> judg, vars-asms) => vars-unify;
		<sx-unify(|vars-unify)> (<sx-concl> deriv, judg) => result;
		<sx-res-possible-assumptions(|vars-asms)> (derivs, judg) => candidates;
		if !result; ?SXUnificationFailure(_) then
			!candidates
		else
			![(deriv, <sx-res-sub-to-eqs> result) | candidates]
		end

	/**
	 * Finds inference rules that possibly solve the given goal
	 *
	 * The result is a list of tuples of the premises to satisfy, the
	 * rule name, and constraints. The constraints must hold for
	 * this rule to possible prove a derivation of the goal.
	 *
	 * @param vars List(SXMetaVar)
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type (List(SXInfRule), SXJudgement, SXStore)
	 *       -> List((List(SXJudgement), String, SXStore))
	 */
	sx-res-possible-rules(|vars-asms) =
		?([], judg, store); ![]
	sx-res-possible-rules(|vars-asms) =
		?([inf-rule|inf-rules], judg, store);
 		//where(<debug(!"ORIG RULE  ")> inf-rule);
 		<sx-fresh-inf-rule> inf-rule => rule-fresh;
		//where(<debug(!"FRESH RULE ")> rule-fresh);
 		//debug(!"FRESH RULE ");
 		<sx-vars> rule-fresh => vars-rule;
 		<sx-vars> judg => vars-judg;
 		//debug(!"VARS JUDG ");
 		<diff> (<union> (vars-rule, vars-judg), vars-asms) => vars-unify;
 		//debug(!"DIFF ");
 		//<debug(!"Trying to unify\n ")> (<sx-concl> rule-fresh);
 		//<debug(!"and            \n ")> judg;
 		<sx-unify(|vars-unify)> (<sx-concl> rule-fresh, judg) => result;
 		//debug(!"UNIFIED ");
 		<sx-res-possible-rules(|vars-asms)> (inf-rules, judg, store) => candidates;
 		//debug(!"CANDIDATES ");
 		if !result; ?SXUnificationFailure(_) then
 			//debug(!"UNIF FAIL ");
 			!candidates 			
 		else
 			<sx-inf-rule-premises> rule-fresh => premises;
 			<sx-inf-rule-name> rule-fresh => name;
 			//debug(!"NAME ");
 			<sx-res-sub-to-eqs> result => eqs;
 			![(premises, name, eqs) | candidates]
 		end
 		
	/**
	 * Picks all non failure answers or keeps all (failure) answers
	 *
	 * @type List(SXAnswer) -> List(SXAnswer)
	 */
	sx-res-filter-answers =
		?answers;
		let filter-s =
			{ store, deriv:
				?(store, deriv);
				<not(sx-is-failure-deriv)> deriv
			}
		in
			<filter(not(sx-is-failure-deriv))> answers
		end  => answers-valid;
		if !answers-valid; ?[] then
			!answers
		else
			!answers-valid
		end

	/**
	 * Solves the constraint store and apply solution to the derivation
	 *
	 * @type SXAnswer -> SXAnswer
	 */
	sx-res-sub-variables(|vars-asms) =
		?(store, deriv);
		debug(!"RES SUB VARS ");
		<sx-res-solve(|vars-asms)> store => sub;
		where(hashtable-getlist; debug(!"SOLUTION TO STORE "));
		<sx-sub-apply> (sub, deriv) => deriv1;
		where(<debug(!"DERIV  ")> deriv);
		where(<debug(!"DERIV 1 ")> deriv1);

		!(store, deriv1)

/**
 * Constraint store
 */
strategies
	/**
	 * Returns an empty constraint store
	 *
	 * @type _ -> SXStore
	 */
	sx-res-empty-store =
		![]

	/** 
	 * Propagates a list of constraints to the store
	 *
	 * It returns SXFalse() if the store is not satisfiable,
	 * SXTrue() otherwise.
	 *
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type (List(SXJudgement), SXStore) -> (SXBool, SXStore)
	 */
	sx-res-propagate(|vars-asm) =
		?(constrs, store);
		<sx-res-simplify(|vars-asm)> (<conc> (constrs, store))

	/**
	 * Simplifies the given store
	 *
	 * It returns SXFalse() if the store is not satisfiable
	 * and SXTrue() otherwise.
	 *
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type SXStore -> (SXBool, SXStore)
	 */
	sx-res-simplify(|vars-asm) =
		//debug(!"ENTERED SIMPLIFY ");
		?store;
		<sx-res-partition-store> store => (eqs, neqs);
		//debug(!"partitioned");
		<sx-vars> eqs => vars-eqs;
		<diff> (vars-eqs, vars-asm) => vars-unify;
		<map(\SXEq(expr1, expr2) -> (expr1, expr2)\)> eqs => eq-pairs;
		<sx-unify(|vars-unify)> eq-pairs => result;
		if !result; ?SXUnificationFailure(_) then
			//debug(!"FAILED");
			!(SXFalse(), store)
		else
			//where(hashtable-getlist; debug(!"SUCCEEDED"));
			<sx-sub-apply> (result, neqs) => neqs1;
			//where(debug(!"NEQS 1 "));
			<sx-res-sub-to-eqs> result => eqs1;
			<conc> (eqs1, neqs1) => store1;
			if <sx-res-satisfiable> neqs1 then
				!(SXTrue(), store1)
			else
				!(SXFalse(), store1)
			end
		end

	/**
	 * Partitions the store in equality and inequality constraints
	 *
	 * @type SXStore -> (SXStore, SXStore)
	 */
	sx-res-partition-store =
		partition(sx-is-eq-judgement)

	/**
	 * Converts a substitution to equality judgements (constraints)
	 *
	 * @type SXSub -> List(SXJudgement)
	 */
	sx-res-sub-to-eqs =
		let fold-s(|constrs) =
			{var, expr:
				?(var, expr);
				![SXEq(var, expr) | constrs]
			}
		in
			sx-sub-fold(fold-s|[])
		end

	/**
	 * Converts a list of equality constraints to a substitution
	 *
	 * This only makes sense if the lhs of the constraints are
	 * metavariables. The Strategy fails if this is not the case.
	 *
	 * @type List(SXJudgement) -> SXSub
	 */
	sx-res-eqs-to-sub =
		?eqs;
		let fold-s(|sub1) =
			{var, expr:
				?SXEq(var, expr);
				<sx-is-metavar> var;
				<sx-sub-union> (sub1, <sx-sub-singleton> (var, expr))
			}
		in
			sx-sub-empty => sub-empty;
			<list-fold(fold-s|sub-empty)> eqs
		end

	/**
	 * Checks if the given inequality constraints have a solution
	 *
	 * @type SXStore -> _
	 */
	sx-res-satisfiable =
		?[]
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<sx-is-metavar> expr2;
		if <eq> (expr1, expr2) then
			fail
		else
			<sx-res-satisfiable> constrs
		end
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<not(sx-is-metavar)> expr2;
		<sx-res-satisfiable> constrs
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<sx-is-metavar> expr2;
		<sx-res-satisfiable> constrs
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<not(sx-is-metavar)> expr2;
		if <eq> (expr1, expr2) then
			fail
		else
			<sx-res-satisfiable> constrs
		end

	/**
	 * Calculates a solution for the store
	 *
	 * It returns the empty substitution if the store has no
	 * solution.
	 *
	 * @param vars-asm List(SXMetaVars)
	 *
	 * @type SXStore -> SXSub
	 */
	sx-res-solve(|vars-asm) =
		?store;
		<sx-res-simplify(|vars-asm)> store => (ok, store1);
		debug(!"SIMLIFIED ");
		if !ok; ?SXTrue() then
			<sx-res-partition-store> store1 => (eqs, neqs);
			//debug(!"PART IN RES SOL");
			<sx-res-eqs-to-sub> eqs => sub-eqs;
			//debug(!"SUB TO EQS ");
			<sx-res-assign-neqs> neqs => sub-neqs;
			<sx-sub-compose> (sub-neqs, sub-eqs)
		else
			sx-sub-empty
		end

	/**
	 * Assigns a solution to the inequalities
	 *
	 * @type List(SXJudgement) -> SXSub
	 */
	sx-res-assign-neqs =
		?constrs;
		<collect-all(sx-is-metavar)> constrs => vars;
		<collect-all(is-string, union, (sx-is-metavar; ![]))> constrs => lexs;
		let fold-s(|sub1) =
			{var:
				?var;
				<sx-metavar-name> var => name;
				<sx-res-newname(|lexs)> name => name1;
				<sx-sub-union> (sub1, <sx-sub-singleton> (var, name1))
			}
	 	in
	 		sx-sub-empty => sub-empty;
	 		<list-fold(fold-s|sub-empty)> vars
	 	end

	/**
	 * Returns a fresh name not contained in the given list of names
	 *
	 * @param names List(String)
	 *
	 * @type String -> String
	 */
	sx-res-newname(|names) =
		?name;
		<newname> name => name1;
		if <elem> (name1, names) then
			<sx-res-newname(|names)> name
		else
			!name1
		end

	/**
	 * Removes inequalities that cannot be satisfied from the store
	 *
	 * @type SXStore -> SXStore
	 */
	sx-res-remove-conflicting-neqs =
		?[]
	sx-res-remove-conflicting-neqs =
		?[constr@SXEq(_, _) | constrs];
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		![constr|constrs1]
	sx-res-remove-conflicting-neqs =
		?[constr@SXGetInterface(_, _) | constrs];
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		![constr|constrs1]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<sx-is-metavar> expr2;
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		if <eq> (expr1, expr2) then
			!constrs1
		else
			![constr|constrs1]
		end
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<not(sx-is-metavar)> expr2;
		![constr | <sx-res-remove-conflicting-neqs> constrs]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<sx-is-metavar> expr2;
		![constr | <sx-res-remove-conflicting-neqs> constrs]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<not(sx-is-metavar)> expr2;
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		if <eq> (expr1, expr2) then
			!constrs1
		else
			![constr|constrs1]
		end
		
/**
 * Various
 */
strategies
	/**
	 * A combination of map-accuml and mapconcat
	 *
	 * @param s(|a) b -> List((a, List(c)))
	 * @param acc a
	 *
	 * @type List(b) -> List((a, List(c)))))
	 */
	sx-mapconcat-accuml(s|acc) =
		?[]; ![(acc,[])]
	sx-mapconcat-accuml(s|acc) =
		?[x|xs];
		let map-s1 =
			{ acc1, x1:
				?(acc1, x1);
				let map-s2 =
					{ acc2, xs2:
						?(acc2, xs2);
						![(acc2, [x1|xs2])]
					}
				in
					<mapconcat(map-s2)> (<sx-mapconcat-accuml(s|acc1)> xs)
				end
			}
		in
			!x; s(|acc); mapconcat(map-s1) 
		end
		// The code is a conversion of the list comprehension
		// [ (acc, x1:xs2)
		// | (acc1, x1) <- f acc x
        // , (acc2, xs2) <- concatMapAccumL f acc1 xs ]
        // from the Haskell prototype
