/**
 * SoundX resolution procedure
 *
 * The procedure either return one valid derivation
 * or a list of invalid derivations containing error nodes.
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/Resolution

imports org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Unification
		org/sugarj/soundx/Substitution


/**
 * Derivation building
 */
strategies
	/**
	 * Builds a derivation given a list of assumptions, inference rules,
	 * and a goal judgement
	 *
	 * @type (List(SXDeriv), List(SXInfRule), SXJudgement) -> SXEither(List(SXDeriv), SXDeriv)
	 */
	sx-res-build-derivation =
		id

	/**
	 * Derives a list of answers (pair of derivation and store) for a goal
	 *
	 * @param vars List(SXMetaVar)
	 * @param vars-asms List(SXMetaVar)
	 *
	 * @type (List(SXDeriv), List(SXInfRule), SXStore, SXJudgement) -> List(SXAnswer)
	 */
	sx-res-derive-answers(|vars, vars-asms) =
		// TODO
		fail
	sx-res-derive-answers(|vars, vars-asms) =
		// Inequality judgement
		?(asms, inf-rules, store, judg@SXNeq(expr1, expr2));
		<sx-res-propagate(|vars-asms)> ([judg], store) => (ok, store1);
		if !ok; ?SXTrue() then
			![(store1, SXDerivFail(judg))]
		else
			![(store1, SXDerivInst([], "Neq", judg))]
		end => answers-constr;
		<sx-res-derive-by-asm(|vars-asms)> (asms, store, judg) => answers-asm;
		<sx-res-filter-answers> (<conc> (answers-constr, answers-asm))
	sx-res-derive-answers(|vars, vars-asms) =
		// Inductively defined judgement
		?(asms, inf-rules, store, judg);
		<sx-is-ind-def-judgement> judg => (name, args);
		<sx-res-possible-rules(|vars, vars-asms)> (inf-rules, judg, store) => candidates;
		let map-s1 =
			{ premises, name, eqs:
				?(premises, name, eqs);
				<sx-res-propagate(|vars-asms)> (eqs, store) => (ok, store1);
				if !ok; ?SXTrue() then
					let map-s2 =
						{ store3, deriv, store4:
							?(store3, derivs);
							<sx-res-remove-conflicting-neqs> store3 => store4;
							![(store4, SXDerivInst(derivs, name, judg))]
						}
					in
						let map-accum-s(|store2) =
							{ premise:
								?premise;
								<sx-res-derive-answers(|vars, vars-asms)>
									(asms, inf-rules, store2, premise) 
							}
						in
							<sx-mapconcat-accuml(map-accum-s|store1)> premises => answers;
							<mapconcat(map-s2)> answers
						end 
					end
				else
					![]
				end
			}
		in
			<mapconcat(map-s1)> candidates
		end => answers-inf-rules;
		<sx-res-derive-by-asm(|vars-asms)> (asms, store, judg) => asnwers-asms

	/**
	 * Tries to derive answers for a judgement using only the assumptions
	 *
	 * @param vars List(SXMetaVar)
	 *
	 * @type (List(SXDeriv), SXStore, SXJudgement) -> List(SXAnswer)
	 */
	sx-res-derive-by-asm(|vars-asms) =
		?(asms, store, judg);
		<sx-res-possible-assumptions(|vars-asms)> (asms, judg) => candidates;
		let map-s =
			{ deriv, eqs, ok, store1:
				?(deriv,eqs);
				<sx-res-propagate(|vars-asms)> (eqs, store) => (ok, store1);
				if !ok; ?SXTrue() then
					![(store1, deriv)]
				else
					![]
				end
			}
		in
			<mapconcat(map-s)> candidates
		end

	/**
	 * Finds assumptions that possible solve the goal judgement
	 *
	 * The result is a list of pairs of assumptions and constraints.
	 * The constraints must hold for the accompagnying assumption to
	 * possibly solve the goal.
	 *
	 * @param vars-asm List(SXMetaVars)
	 *
	 * @type (List(SXDeriv), SXJudgement) -> List((SXDeriv, SXStore))
	 */
	sx-res-possible-assumptions(|vars-asms) =
		?([], judg); ![]
	sx-res-possible-assumptions(|vars-asms) =
		?([deriv|derivs], judg);
		<diff> (<sx-vars> judg, vars-asms) => vars-unify;
		<sx-unify(|vars-unify)> (<sx-concl> deriv, judg) => result;
		<sx-res-possible-assumptions(|vars-asms)> (derivs, judg) => candidates;
		if !result; ?SXUnificationFailure(_) then
			!candidates
		else
			![(deriv, <sx-res-sub-to-eqs> result) | candidates]
		end

	/**
	 * Finds inference rules that possibly solve the given goal
	 *
	 * The result is a list of tuples of the premises to satisfy, the
	 * rule name, and constraints. The constraints must hold for
	 * this rule to possible prove a derivation of the goal.
	 *
	 * @param vars List(SXMetaVar)
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type (List(SXInfRule), SXJudgement, SXStore)
	 *       -> List((List(SXJudgement), String, SXStore))
	 */
	sx-res-possible-rules(|vars, vars-asms) =
		?([], judg, store); ![]
	sx-res-possible-rules(|vars, vars-asms) =
		?([inf-rule|inf-rules], judg, store);
 		<sx-fresh-inf-rule> inf-rule => rule-fresh;
 		<sx-vars> rule-fresh => vars-rule;
 		<sx-vars> judg => vars-judg;
 		<diff> (<union> (vars-rule, vars-judg), vars-asms) => vars-unify;
 		<sx-unify(|vars-unify)> (<sx-concl> rule-fresh, judg) => result;
 		<sx-res-possible-rules(|vars, vars-asms)> inf-rules => candidates;
 		if !result; SXTrue() then
 			<sx-inf-rule-premises> rule-fresh => premises;
 			<sx-inf-rule-premises> rule-fresh => name;
 			<sx-res-sub-to-eqs> result => eqs;
 			![(premises, name, eqs) | candidates]
 		else
 			!candidates
 		end
 		
	/**
	 * Picks the first non failure answer or keeps all (failure) answers
	 *
	 * @type List(SXAnswer) -> List(SXAnswer)
	 */
	sx-res-filter-answers =
		?answers;
		<filter(not(sx-is-failure-deriv))> answers => answers-valid;
		if !answers-valid; ?[] then
			!answers
		else
			!answers-valid
		end

/**
 * Constraint store
 */
strategies
	/**
	 * Returns an empty constraint store
	 *
	 * @type _ -> SXStore
	 */
	sx-res-empty-store =
		![]

	/** 
	 * Propagates a list of constraints to the store
	 *
	 * It returns SXFalse() if the store is not satisfiable,
	 * SXTrue() otherwise.
	 *
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type (List(SXJudgement), SXStore) -> (SXBool, SXStore)
	 */
	sx-res-propagate(|vars-asm) =
		?(constrs, store);
		<sx-res-simplify(|vars-asm)> (<conc> (constrs, store))

	/**
	 * Simplifies the given store
	 *
	 * It returns SXFalse() if the store is not satisfiable
	 * and SXTrue() otherwise.
	 *
	 * @param vars-asm List(SXMetaVar)
	 *
	 * @type SXStore -> (SXBool, SXStore)
	 */
	sx-res-simplify(|vars-asm) =
		?store;
		<sx-res-partition-store> store => (eqs, neqs);
		<sx-vars> eqs => vars-eqs;
		<diff> (vars-eqs, vars-asm);
		<map(\SXEq(expr1, expr2) -> (expr1, expr2)\)> eqs => eq-pairs;
		<sx-unify(|vars-eqs)> eq-pairs => result;
		if !result; ?SXUnificationFailure(_) then
			!(SXFalse(), store)
		else
			<sx-sub-apply> (result, neqs) => neqs1;
			<sx-res-sub-to-eqs> result => eqs1;
			<conc> (eqs1, neqs) => store1;
			if <sx-res-satisfiable> neqs1 then
				!(SXTrue(), store1)
			else
				!(SXFalse(), store1)
			end
		end

	/**
	 * Partitions the store in equality and inequality constraints
	 *
	 * @type SXStore -> (SXStore, SXStore)
	 */
	sx-res-partition-store =
		partition(sx-is-eq-judgement)

	/**
	 * Converts a substitution to equality judgements (constraints)
	 *
	 * @type SXSub -> List(SXJudgement)
	 */
	sx-res-sub-to-eqs =
		let fold-s(|constrs) =
			{var, expr:
				?(var, expr);
				![SXEq(var, expr) | constrs]
			}
		in
			sx-sub-fold(fold-s|[])
		end

	/**
	 * Converts a list of equality constraints to a substitution
	 *
	 * This only makes sense if the lhs of the constraints are
	 * metavariables. The Strategy fails if this is not the case.
	 *
	 * @type List(SXJudgement) -> SXSub
	 */
	sx-res-eqs-to-sub =
		let fold-s(|sub1) =
			{var, expr:
				?SXEq(var, expr);
				<sx-is-metavar> var;
				<sx-sub-union> (sub1, <sx-sub-singleton> (var, expr))
			}
		in
			sx-sub-empty => sub-empty;
			list-fold(fold-s|sub-empty)
		end

	/**
	 * Checks if the given inequality constraints have a solution
	 *
	 * @type SXStore -> _
	 */
	sx-res-satisfiable =
		?[]
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<sx-is-metavar> expr2;
		if <eq> (expr1, expr2) then
			fail
		else
			<sx-res-satisfiable> constrs
		end
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<not(sx-is-metavar)> expr2;
		<sx-res-satisfiable> constrs
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<sx-is-metavar> expr2;
		<sx-res-satisfiable> constrs
	sx-res-satisfiable =
		?[SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<not(sx-is-metavar)> expr2;
		if <eq> (expr1, expr2) then
			fail
		else
			<sx-res-satisfiable> constrs
		end

	/**
	 * Calculates a solution for the store
	 *
	 * It returns the empty substitution if the store has no
	 * solution.
	 *
	 * @param vars-asm List(SXMetaVars)
	 *
	 * @type SXStore -> SXSub
	 */
	sx-res-solve(|vars-asm) =
		?store;
		<sx-res-simplify(|vars-asm)> store => (ok, store1);
		if !ok; ?SXTrue() then
			<sx-res-partition-store> store1 => (eqs, neqs);
			<sx-res-eqs-to-sub> eqs => sub-eqs;
			<sx-res-assign-neqs> neqs => sub-neqs;
			<sx-sub-compose> (sub-neqs, sub-eqs)
		else
			sx-sub-empty
		end

	/**
	 * Assigns a solution to the inequalities
	 *
	 * @type List(SXJudgement) -> SXSub
	 */
	sx-res-assign-neqs =
		?constrs;
		<collect-all(sx-is-metavar)> constrs => vars;
		<collect-all(is-string, union, (sx-is-metavar; ![]))> constrs => lexs;
		let fold-s(|sub1) =
			{var:
				?var;
				<sx-metavar-name> var => name;
				<sx-res-newname(|lexs)> name => name1;
				<sx-sub-union> (sub1, <sx-sub-singleton> (var, name1))
			}
	 	in
	 		sx-sub-empty => sub-empty;
	 		<list-fold(fold-s|sub-empty)> vars
	 	end

	/**
	 * Returns a fresh name not contained in the given list of names
	 *
	 * @param names List(String)
	 *
	 * @type String -> String
	 */
	sx-res-newname(|names) =
		?name;
		<newname> name => name1;
		if <elem> (name1, names) then
			<sx-res-newname(|names)> name
		else
			!name1
		end

	/**
	 * Removes inequalities that cannot be satisfied from the store
	 *
	 * @type SXStore -> SXStore
	 */
	sx-res-remove-conflicting-neqs =
		?[]
	sx-remove-conflicting-neqs =
		?[constr@SXEq(_, _) | constrs];
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		![constr|constrs1]
	sx-remove-conflicting-neqs =
		?[constr@SXGetInterface(_, _) | constrs];
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		![constr|constrs1]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<sx-is-metavar> expr2;
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		if <eq> (expr1, expr2) then
			!constrs1
		else
			![constr|constrs1]
		end
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<sx-is-metavar> expr1;
		<not(sx-is-metavar)> expr2;
		![constr | <sx-res-remove-conflicting-neqs> constrs]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<sx-is-metavar> expr2;
		![constr | <sx-res-remove-conflicting-neqs> constrs]
	sx-res-remove-conflicting-neqs =
		?[constr@SXNeq(expr1, expr2) | constrs];
		<not(sx-is-metavar)> expr1;
		<not(sx-is-metavar)> expr2;
		<sx-res-remove-conflicting-neqs> constrs => constrs1;
		if <eq> (expr1, expr2) then
			!constrs1
		else
			![constr|constrs1]
		end
		
/**
 * Various
 */
strategies
	/**
	 * A combination of map-accuml and mapconcat
	 *
	 * @param s(|a) b -> List((a, List(c)))
	 * @param acc a
	 *
	 * @type List(b) -> List((a, List(c)))))
	 */
	sx-mapconcat-accuml(s|acc) =
		?[]; ![(acc,[])]
	sx-mapconcat-accuml(s|acc) =
		?[x|xs];
		let map-s1 =
			{ acc1, x1:
				?(acc1, x1);
				let map-s2 =
					{ acc2, xs2:
						?(acc2, xs2);
						![(acc2, [x1|xs2])]
					}
				in
					<mapconcat(map-s2)> (<sx-mapconcat-accuml(s|acc1)> xs)
				end
			}
		in
			!x; s(|acc); mapconcat(map-s1) 
		end
		// The code is a conversion of the list comprehension
		// [ (acc, x1:xs2)
		// | (acc1, x1) <- f acc x
        // , (acc2, xs2) <- concatMapAccumL f acc1 xs ]
        // from the Haskell prototype
