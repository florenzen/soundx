/**
 * Unification
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/Unification

imports org/sugarj/soundx/Substitution
		org/sugarj/soundx/AbstractSyntax


strategies
	/**
	 * Unifies a list of pairs of expressions
	 *
	 * It either returns a substitution or SXUnificationFailure(msg).
	 * The vars argument takes the list of unification variables.
	 *
	 * @param vars List(SXMetaVar)
	 * @type List((a, a)) -> SXUnificationResult
	 */
	sx-unify(|vars) =
		// Empty list, termination case
		?[]; sx-sub-empty
		//;where(hashtable-getlist; debug(!"RESULT "))
	sx-unify(|vars) =
		// Two variables
		?[(var1, var2) | pairs];
		<sx-is-metavar> var1;
		<sx-is-metavar> var2;
		//<debug(!"V V ")> (var1, var2);
		if <eq> (var1, var2) then
			<sx-unify(|vars)> pairs
		else
			if <elem> (var1, vars) then
				<sx-sub-singleton> (var1, var2)
			else
				if <elem> (var2, vars) then
					<sx-sub-singleton> (var2, var1)
				else
					// TODO better error message
					!SXUnificationFailure("could not unify variables")
				end
			end => result;
			if !result; ?SXUnificationFailure(_) then
				!result
			else
				<map(\pair -> <sx-sub-apply> (result, pair)\)> pairs => pairs1;
				<sx-unify(|vars)> pairs1 => result1;
				if !result1; ?SXUnificationFailure(_) then
					!result1
				else
					<sx-sub-compose> (result1, result)
					//;where(hashtable-getlist; debug(!"RESULT "))
				end
			end
		end
	sx-unify(|vars) =
		// One variable, on other expression
		?[(var1, expr2) | pairs];
		<sx-is-metavar> var1;
		<not(sx-is-metavar)> expr2;
		//<debug(!" V E ")> [(var1, expr2)|pairs];
		if <elem> (var1, vars) then
			//debug(!" V E IF ");
			<sx-vars> expr2 => vars-expr2;
			if <elem> (var1, vars-expr2) then
				// TODO: better error message
				!SXUnificationFailure("occurs check failed")
			else
				<sx-sub-singleton> (var1, expr2) => sub1;
				<map(\pair -> <sx-sub-apply> (sub1, pair)\)> pairs => pairs1;
				<sx-unify(|vars)> pairs1 => result;
				if !result; ?SXUnificationFailure(_) then
					!result
				else
					//where(<hashtable-getlist; debug(!"BEFORE RESULT 1")> sub1);
					//where(<hashtable-getlist; debug(!"BEFORE RESULT 2")> result);
					<sx-sub-compose> (sub1, result)
					//;where(hashtable-getlist; debug(!"RESULT "))
				end
			end
		else
			//debug(!"V E ELSE ");
			// TODO: better error message
			!SXUnificationFailure("not a unification variable")
		end
	sx-unify(|vars) =
		// One other expression, one variable
		?[(expr1, var2) | pairs];
		<not(sx-is-metavar)> expr1;
		<sx-is-metavar> var2;
		//<debug(!" E V ")> (expr1, var2);
		<sx-unify(|vars)> [(var2, expr1) | pairs]
		//;where(hashtable-getlist; debug(!"RESULT "))
	sx-unify(|vars) =
		// Two non-variable expressions
		?[(expr1, expr2) | pairs];
		<not(sx-is-metavar)> expr1;
		<not(sx-is-metavar)> expr2;
		//<debug(!" E E ")> (expr1, expr2);
		!expr1; ?con1#(args1);
		!expr2; ?con2#(args2);
		if <eq> (con1, con2) then
			if <eq> (<length> args1, <length> args2) then
				//where(<debug(!"ARGS ARGS ")> (args1, args2));
				<sx-unify(|vars)> (<conc> (<zip> (args1, args2), pairs))
				//;where(debug(!"RESULT "))
			else
				// TODO: better error message
				!SXUnificationFailure("differen number of arguments")
			end
		else
			//debug(!"DIFFEREN CONS ");
			!SXUnificationFailure(<conc-strings> ("different constructor names ", con1, " ", con2))
			//;debug(!"UN FAIL ")
		end

	/**
	 * Unifies a pair of expressions
	 *	
	 * It either returns a substitution or SXUnificationFailure(msg).
	 * The vars argument takes the list of unification variables.
	 *
	 * @param vars List(SXMetaVar)
	 * @type (a, a) -> SXUnificationResult
	 */	
	sx-unify(|vars) =
		?(expr1, expr2);
		<sx-unify(|vars)> [(expr1, expr2)]
		//;where(hashtable-getlist; debug(!"Final result "))
