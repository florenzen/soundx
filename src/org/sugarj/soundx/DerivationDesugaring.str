/**
 * The SoundX derivation desugaring procedure
 *
 * TODO error handling should not use sx-debug and fail
 *
 * @author Florian Lorenzen <florian.lorenzen>
 */
module org/sugarj/soundx/DerivationDesugaring

imports org/sugarj/soundx/AbstractSyntax
		org/sugarj/soundx/Unification
		org/sugarj/soundx/Substitution
		org/sugarj/soundx/Declarations
		org/sugarj/soundx/DepthFirstBC
		org/sugarj/soundx/BasicDesugaring
		org/sugarj/soundx/Classification
		org/sugarj/soundx/Environment

imports org/sugarj/soundx/Debug


strategies
	/**
	 * Desugars a derivation
	 *
	 * It either returns the desugared list of toplevel declarations
	 * or it aborts if it is stuck in the forward step
	 *
	 * @type _ -> List(ToplevelDeclaration)
	 */
	sx-derivation-desugaring =
		sx-env-get-derivation => deriv;
		<debug(!"FOUND DERIVATION TO DESUGAR")> "";
		sx-env-get-re-exports => imported-exts;
		debug(!"FOUND RE EXPORTS ");
		<sx-deriv-desugar-from-imports(|imported-exts)> deriv => deriv-des;
		debug(!"FINISHED DESUGARING ");
		// extract desugared program from desugared cocnlusion
		<sx-concl> deriv-des => concl-des;
		debug(!"DESUGARED CONCLUSION ");
		sx-interface-judgement => (tlds-pattern, intf-pattern, judg);
		<sx-vars> judg => judg-vars;
		<sx-unify(|judg-vars)> (judg, concl-des) => result;
		if !result; ?SXUnificationFailure(_) then
			<sx-debug(|"could not unify interface judgement and desugared conclusion (defect of base language definition)")> "";
			fail
		else
			<sx-sub-apply> (result, tlds-pattern) => des-program;
			debug(!"DESUGARED PROGRAM ");
			<sx-toplevel-decls-to-list> des-program
		end

	/**
	 * Desugars one extension after the other from beginning to end of the list.
	 *
	 * @param imported-exts List(String)
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-from-imports(|imported-exts) =
		?deriv;
		!imported-exts;
		((?[];
		  !deriv
		 ) <+
		 (?[imp-ext|imp-exts];
		  <sx-deriv-desugar-from-imports(|imp-ext, imp-exts)> deriv => deriv-des;
		  <sx-deriv-desugar-from-imports(|imp-exts)> deriv-des
		 )
		)
		
	/**
	 * Desugars one extension given the name of the current extension
	 * and the names of the imported extensions.
	 *
	 * @param current-ext String
	 * @param impored-exts List(String)
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-from-imports(|current-ext, imported-exts) =
		?deriv;
		<sx-extension-inference-rules> current-ext => ext-inf-rules;
		debug(!"CURRENT EXT INF RULES ");
		<mapconcat(sx-extension-inference-rules)> imported-exts => inf-rules-imported;
		debug(!"IMPORTED INF RULES ");
		sx-inference-rules => base-inf-rules;
		debug(!"BASE INF RULES ");
		<conc> (base-inf-rules, inf-rules-imported) => base-imp-rules;
		debug(!"ALL INF RULES ");
		<sx-deriv-desugar-ext-base(|current-ext, ext-inf-rules, base-imp-rules)> deriv

	/**
	 * Desugars one extension given the name of the current extension
	 * the inference rules of the extension and the inference rules of
	 * the base system
	 *
	 * @param current-ext String
	 * @param ext-inf-rules List(SXInfRule)
	 * @param base-inf-rules List(SXInfRule))
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-ext-base(|current-ext, ext-inf-rules, base-inf-rules) =
		debug(!"BEFORE DU");
		sx-deriv-downup(
			sx-deriv-desugar-top-down(|current-ext, ext-inf-rules, base-inf-rules),
			sx-deriv-desugar-bottom-up(|current-ext, ext-inf-rules, base-inf-rules))

	/**
	 * Downup strategy for derivation trees. It is a specilization of
	 * the downup strategy.
	 * 
	 * @param down-s SXDeriv -> SXDeriv
	 * @param up-s SXDeriv -> SXDeriv
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-downup(down-s, up-s) =
		down-s => SXDerivInst(subderivs1, rule-name1, concl1);
		<map(sx-deriv-downup(down-s, up-s))> subderivs1 => subderivs2;
		<up-s> SXDerivInst(subderivs2, rule-name1, concl1)
		// We could also use downup and wrap sx-deriv-desugar-top-down
		// and sx-deriv-desugar-bottom-up such that they also
		// succeed with id on all the subterms but sx-deriv-downup
		// is more direct and performs fewer traversals.

	/**
	 * The one-step top-down rewriting of derivations
	 *
	 * @param current-ext String
	 * @param ext-inf-rules List(SXInfRule)
	 * @param base-inf-rules List(SXInfRule))
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-top-down(|current-ext, ext-inf-rules, base-inf-rules) =
		?deriv@SXDerivInst(subderivs, rule-name, concl);
		debug(!"TOP DOWN ");
		(// base language rule (this implements TD-Base)
		 (<sx-deriv-desugar-is-rule-defined-in(|base-inf-rules)> rule-name;
		  debug(!"TD BASE RULE ");
		  !deriv
		 ) <+
		 // extension rule
		 (<sx-deriv-desugar-is-rule-defined-in(|ext-inf-rules)> rule-name => current-inf-rule;
		  debug(!"TD EXT RULE");
		  <sx-fresh-inf-rule> current-inf-rule => fresh-inf-rule@SXInfRule(premises-fresh, _, concl-fresh);
		  if <sx-classify-inf-rule-x(|current-ext, ext-inf-rules, base-inf-rules)> fresh-inf-rule then
		  	// X rule (this implementes TD-ExtExt)
		  	<sx-basic-desugar-inf-rule(|current-ext)> fresh-inf-rule => SXInfRule(premises-des, _, concl-des);
		  	<sx-vars> concl-des => vars-concl-des;
		  	<map(sx-concl)> subderivs => concl-subderivs;
		  	<sx-unify(|vars-concl-des)> ([concl-fresh|premises-fresh], [concl|concl-subderivs]) => result;
		  	if !result; ?SXUnificationFailure(_) then
		  		<sx-debug(|"BUG! Unification in TD-ExtExt failed for rule: ")> rule-name;
		  		fail
		  	else
		  		<sx-sub-apply> (result, concl-des) => concl-des-instantiated;
		  		<conc> (base-inf-rules, ext-inf-rules) => all-inf-rules;
		  		if <sx-dfsbc-build-derivation> (subderivs, all-inf-rules, concl-des-instantiated) => deriv-des then
		  			!deriv-des
		  		else
		  			<sx-debug(|"Bug: Bridging the gap in TD-ExtExt failed for rule: ")> rule-name;
		  			fail
		  		end
		  	end
		  else
		  	// B rule (this implements TD-ExtBase)
		  	!deriv
		  end
		 ) <+
		 // serious error: rule cannot be found
		 (<sx-debug(|"*** ERROR *** A rule used in a derivation cannot be found: ")> rule-name;
		  fail)
	    )

	/**
	 * The one-step bottom-up rewriting of derivations
	 *
	 * @param current-ext String
	 * @param ext-inf-rules List(SXInfRule)
	 * @param base-inf-rules List(SXInfRule))
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-bottom-up(|current-ext, ext-inf-rules, base-inf-rules) =
		?deriv@SXDerivInst(_, rule-name, _);
		debug(!"BOTTOM UP ");
		(// base language rule
		 (<sx-deriv-desugar-is-rule-defined-in(|base-inf-rules)> rule-name => current-inf-rule;
		  <sx-deriv-desugar-bottom-up-base(|current-ext, current-inf-rule)> deriv
		 ) <+
		 // extension rule
		 (<sx-deriv-desugar-is-rule-defined-in(|ext-inf-rules)> rule-name => current-inf-rule;
		  <sx-deriv-desugar-bottom-up-ext(|current-ext, current-inf-rule, base-inf-rules)> deriv
		 ) <+
		 // serious error: rule cannot be found
		 (<sx-debug(|"*** ERROR *** A rule used in a derivation cannot be found: ")> rule-name;
		  fail)
		)

	/**
	 * One-step bottom-up rewriting for base language rule
	 *
	 * TODO error handling in forward step failure
	 *
	 * @param current-inf-rule SXInfRule
	 * @param current-ext String
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-bottom-up-base(|current-ext, current-inf-rule) =
		?SXDerivInst(subderivs, rule-name, concl);
		<sx-fresh-inf-rule> current-inf-rule => SXInfRule(premises-rule, _, concl-rule);
		<sx-vars> premises-rule => premises-rule-vars;
		<map(sx-concl)> subderivs => concls-subderivs;
		<zip; sx-unify(|premises-rule-vars)> (premises-rule, concls-subderivs) => result1;
		if !result1; ?SXUnificationFailure(_) then
			<debug(!"RESULT 1 ")> result1
		else
			<hashtable-getlist; debug(!"RESULT 1")> result1
		end;
		<debug(!"PREMISES RULE ")> premises-rule;
		<debug(!"CONCLS SUBDERIVS ")> concls-subderivs;
		if !result1; ?SXUnificationFailure(msg) then
		  	<sx-debug(|"*** STUCK *** forward step stuck on rule ")> rule-name;
		  	<sx-debug(|"*** Unifications returned: ")> msg;
		  	<sx-debug(|"*** Premises:       ")> premises-rule;
		  	<sx-debug(|"*** Subderivations: ")> concls-subderivs;
		  	fail
		else
			<sx-vars> concl-rule => concl-rule-vars;
		  	<sx-unify(|concl-rule-vars)> (concl-rule, concl) => result2;
		  	if !result2; ?SXUnificationFailure(_) then
		  		<sx-debug(|"*** ERROR *** cannot match rule's conclusion and derivation conclusion")> rule-name;
		  		fail
		  	else
		  		<sx-sub-dom> result2 => dom-sub2;
		  		<sx-sub-restrict> (result2, <diff> (dom-sub2, premises-rule-vars)) => sub21;
		  		hashtable-getlist; debug(!"SUB 21 ");
		  		<sx-basic-desugar-sub(|current-ext)> sub21 => sub21-desugared;
		  		hashtable-getlist; debug(!"SUB 21 DES ");
		  		<sx-sub-compose> (sub21-desugared, result1) => sub;
		  		hashtable-getlist; debug(!"SUB COMP ");
		  		!SXDerivInst(subderivs, rule-name, <sx-sub-apply> (sub, concl-rule))
		  	end
		end

	/**
	 * One-step bottom-up rewriting for an extension rule
	 * 
	 * @param current-inf-rule SXInfRule
	 * @param current-ext String
	 * @param base-rules List(SXInfRule)
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-deriv-desugar-bottom-up-ext(|current-ext, current-inf-rule, base-rules) =
		?SXDerivInst(subderivs, rule-name, concl);
		<sx-fresh-inf-rule> current-inf-rule => inf-rule-fresh;
		<sx-basic-desugar-inf-rule(|current-ext)> inf-rule-fresh => SXInfRule(premises-des, _, concl-des);
		<sx-vars> premises-des => premises-des-vars;
		<map(sx-concl)> subderivs => concls-subderivs;
		<zip; sx-unify(|premises-des-vars)> (premises-des, concls-subderivs) => result1;
		if !result1; ?SXUnificationFailure(_) then
		  	<sx-debug(|"*** STUCK *** forward step stuck on desugared form of rule ")> rule-name;
		  	<sx-debug(|"*** Premises:       ")> premises-des;
		  	<sx-debug(|"*** Subderivations: ")> concls-subderivs;
		  	fail
		else
			<sx-vars> concl-des => concl-des-vars;
		  	<sx-unify(|concl-des-vars)> (concl-des, concl) => result2;
		  	if !result2; ?SXUnificationFailure(_) then
		  		<sx-debug(|"*** ERROR *** cannot match rule's conclusion and derivation conclusion")> rule-name;
		  		fail
		  	else
		  		<sx-sub-dom> result2 => dom-sub2;
		  		<sx-sub-restrict> (result2, <diff> (dom-sub2, premises-des-vars)) => sub21;
		  		<sx-basic-desugar-sub(|current-ext)> sub21 => sub21-desugared;
		  		<sx-sub-compose> (sub21-desugared, result1) => sub;
		  		<sx-sub-apply> (sub, concl-des) => desugared-goal;
				if <sx-dfsbc-build-derivation> (subderivs, base-rules, desugared-goal) => deriv-des then
					!deriv-des
				else
					<sx-debug(|"*** ERROR *** cannot fill the gap left by rule ")> rule-name;
					fail
				end		  		
		  	end
		end

	/**
	 * Succeeds if rule-name is defined in the given list of rules
	 * and returns that rule. Always returns an axiom scheme for a primitive
	 * judgement name like =/= or =interface().
	 *
	 * @param rules List(SXInfRule)
	 *
	 * @type String -> SXInfRule
	 */
	sx-deriv-desugar-is-rule-defined-in(|inf-rules) =
		?rule-name;
		((!rule-name; ?"=interface()"; sx-prim-axiom-interface) <+
		 (!rule-name; ?"=/="; sx-prim-axiom-neq) <+ 
		 (debug(!"IS DEFINED IN ");
		  <collect-one(?SXInfRule(_, rule-name, _))> inf-rules
		  ;debug(!"FOUND ")))
