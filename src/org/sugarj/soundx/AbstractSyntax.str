/**
 * SoundX abstract syntax
 *
 * @author Florian Lorenzen <florian.lorenzen@tu-berlin.de>
 */
module org/sugarj/soundx/AbstractSyntax

imports org/sugarj/sxbld/processing/MetaExplode

imports org/sugarj/soundx/Substitution


/**
 * Metavariables
 */
signature constructors
	SXMetaVar:    String       -> SXMetaVar
	SXMetaVarGen: String * Int -> SXMetaVar

strategies
	/**
	 * Translates meta-var to SXMetaVar
	 *
	 * @type a -> a
	 */
    sxbld-meta-var-to-sx-metavar =
    	topdown(try(\meta-var(name) -> SXMetaVar(name)\))

	/**
	 * Checks if term is a metavariable
	 *
	 * @type a -> a
	 */
	sx-is-metavar =
		?SXMetaVar(_) +
		?SXMetaVarGen(_, _)

	/**
	 * Collects all metavariables of an expression
	 *
	 * @type a -> List(SXMetavar)
	 */
    sx-vars =
    	collect-all(sx-is-metavar)

	/**
	 * Returns the name of a metavariable
	 *
	 * @type SXMetaVar -> String
	 */
	sx-metavar-name:
		SXMetaVar(name) -> name
	sx-metavar-name:
		SXMetaVarGen(name, num) -> <conc-strings> (name, <int-to-string> num)

	/**
	 * Returns a fresh variant of a meta variable
	 *
	 * The result is always an SXMetaVarGen(name, num).
	 *
	 * @type SXMetaVar -> SXMetaVar
	 */
	sx-fresh-metavar =
		?SXMetaVar(name);
		<newname> ""; string-to-int => num;
		!SXMetaVarGen(name, num)
	sx-fresh-metavar =
		?SXMetaVarGen(name, _);
		<newname> ""; string-to-int => num;
		!SXMetaVarGen(name, num)

/**
 * Inference rules
 */
signature constructors
	SXInfRule: List(SXJudgement) * String * SXJudgement -> SXAbsInfRule

strategies
	/**
	 * Returns a fresh variant of an inference rule
	 *
	 * @type SXInfRule -> SXInfRule
	 */
	sx-fresh-inf-rule =
		?inf-rule;
		let fresh =
			{ expr, sub, var, sub1:
				?(expr, sub);
				<sx-is-metavar> expr;
				if <sx-sub-defines> (sub, expr) then
					!(<sx-sub-apply> (sub, expr), sub)
				else
					<sx-fresh-metavar> expr => var;
					<sx-sub-compose> (<sx-sub-singleton> (expr, var), sub) => sub1;
					!(var, sub1)
				end
			}
		in
			sx-sub-empty => sub-empty;
			<thread-bottomup(try(fresh))> (inf-rule, sub-empty) => (rule-fresh, _);
			!rule-fresh
		end

	/**
	 * Returns the conclusions of an inference rule.
	 *
	 * @type SXInfRule -> SXJudgement
	 */
	sx-concl =
		?SXInfRule(_, _, concl); !concl

	/**
	 * Returns the name of an inference rule
	 *
	 * @type SXInfRule -> String
	 */
	sx-inf-rule-name =
		?SXInfRule(_, name, _); !name

	/**
	 * Returns the premises of an inference rule
	 *
	 * @type SXInfRule -> List(SXJudgement)
	 */
	sx-inf-rule-premises =
		?SXInfRule(premises, _, _); !premises

/**
 * Judgements
 */
signature constructors
	SXEq:           SXExpr * SXExpr -> SXJudgement
    SXNeq:          SXExpr * SXExpr -> SXJudgement
    SXGetInterface: SXExpr * SXExpr -> SXJudgement

strategies
	/**
	 * Checks if an aterm is a judgement
	 *
	 * A judgement has a constructor named SXJudgement<number> or
	 * is one of the primitive judgement SXNeq, SXGetInterface.
	 *
	 * @type a -> a
	 */
	sx-is-judgement =
		where(sx-is-ind-def-judgement) +
		?SXNeq(_, _) +
		?SXGetInterface(_, _)

	/**
	 * Checks if an aterm is an inductively defined judgement.
	 *
	 * It returns the name of the judgement and ist arguments.
	 *
	 * @type a -> (String, List(SXExpr))
	 */
	sx-is-ind-def-judgement =
		?c#(args);
		<string-starts-with(|"SXJudgement")> c;
		!(c, args)

	/**
	 * Checks if aterm is an SXEq judgement
	 *
	 * @type a -> a
	 */
	sx-is-eq-judgement =
		?SXEq(_, _)

/**
 * Toplevel declaration list
 */
signature constructors
	SXToplevelDeclarationsCons: SXToplevelDeclaration * SXToplevelDeclarations -> SXToplevelDeclarations
	SXToplevelDeclarationsNil:                                                    SXToplevelDeclarations

	SXFinished: List(SXToplevelDeclarations) -> SXFinished

strategies
	/**
	 * Converts list of toplevel declarations into ToplevelDeclarations
	 *
	 * @type List(SXToplevelDeclaration) -> SXToplevelDeclarations
	 */
	sx-list-to-toplevel-decls:
		[] -> SXToplevelDeclarationsNil()
	sx-list-to-toplevel-decls:
		[decl|decls] -> SXToplevelDeclarationsCons(decl, decls1)
		where
			<sx-list-to-toplevel-decls> decls => decls1

	/**
	 * Converts ToplevelDeclarations into list of toplevel declarations
	 *
	 * @type SXToplevelDeclarations -> List(SXToplevelDeclaration)
	 */
	sx-toplevel-decls-to-list:
		SXToplevelDeclarationsNil() -> []
	sx-toplevel-decls-to-list:
		SXToplevelDeclarationsCons(decl, decls) -> [decl|decls1]
		where
			<sx-toplevel-decls-to-list> decls => decls1

/**
 * Derivations
 */
signature constructors
	SXDerivInst: List(SXDeriv) * String * SXJudgement -> SXDeriv
	SXDerivAsm:  SXJudgement                          -> SXDeriv
	SXDerivFail: SXJudgement                          -> SXDeriv

strategies
	/**
	 * Extracts the conclusion from a derivation
	 *
	 * @type SXDeriv -> SXJudgement
	 */
	sx-concl:
		SXDerivInst(_, _, concl) -> concl
	sx-concl:
		SXDerivAsm(concl) -> concl
	sx-concl:
		SXDerivFail(concl) -> concl

	/**
	 * Checks if a derivation is a failure derivation
	 *
	 * A derivation is a failure derivation if it contains at
	 * least one SXDerivFail node.
	 *
	 * @type SXDeriv -> SXDeriv
	 */
	sx-is-failure-deriv =
		where(collect-one(?SXDerivFail(_)))

/**
 * Various
 */
signature constructors
	SXUnificationFailure: String -> SXUnificationResult

	SXFalse: SXBool
	SXTrue:  SXBool
	
	SXLeft:  a -> SXEither(a, b)
	SXRight: b -> SXEither(a, b)
